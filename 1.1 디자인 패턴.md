
## 1.1.1 싱글톤 패턴

### 싱글톤 패턴이 필요한 이유?
> 왜 객체(인스턴스)가 하나여야만 하지?
> -> 인스턴스 생성 비용을 아끼기 위해서

### 싱글톤의 단점
- TDD가 어렵다. 
	- 싱글톤에서는 하나의 미리 만들어진 인스턴스를 가지고 돌려쓰는 것인데, 테스트 코드에서 항상 해당 인스턴스를 가지게 하기가 어렵다.
	그렇다면 어떻게 해결하냐, 의도적으로 미리 넣어준다. -> 의존성 주입 (DI)를 하면 된다!
	싱글톤은 모듈간의 결합을 강하게 만들지만, DI를 통해 결합을 느슨하게 만들 수 있다.

> 싱글톤은 왜 결합을 강하게 만들지? 
> -> 하나를 가지고 계속 돌려쓰니까. 그게 아니면 안되게 만들어버렸는데, 계속해서 넣어줘야만 하니까.

의존성 = 종속성으로, A가 B에 의존한다는 것은, B의 변화로 인해 A도 변해야한다는 것

메인 모듈 하나에서 서브모듈로 일일이 하나하나 주입하던 것을, 의존성 주입자(Dependency Injector)가 가로채서 넣어준다. 그렇게 되면 메인 모듈과 서브 모듈 간의 의존성이 떨어지게 된다. 

> 서브모듈이라는 표현이 적절할까? 책에서는 하위 모듈이라고 나와있긴하다.
> 
> 그렇다면 모듈은 뭘까?
> 모듈은 기능 단위로 코드를 쪼갠 것이다. 단순히 쪼갰다 보다, 하나의 "기능" 단위로 쪼갰다에 초점을 맞추면 될 것 같다. 독립적인 기능이라고 생각하면 되겠다. 
> 모듈화를 하면 유지보수와 재사용성이 높은 코드를 짤 수 있다. 가장 큰 고민은, *어느 정도로 작게 모듈을 분리할 것인가*가 될 것 같다.
> 
> 여기서 객체지향과 모듈화가 어느정도 비슷한 의미를 가지는 것 같은데, 뭐가 다른지도 봐보자.
> 캡슐화를 해서 다른 곳에서 가져다 쓸 수 있지만, 다른 점이 존재한다. 

|  | 클래스(객체=인스턴스) | 모듈 |
| ---- | ---- | ---- |
| 인스턴스화 | O | X |
| 상속 | O | X |
| 목적 | 객체를 만들기 위해 | 클래스에 메소드를 제공하기 위해 (클래스에서 사용할 기능을 제공하기 위해) |



### 의존성 주입

- 의존성 주입의 장점
	- 모듈들을 교체하기 쉬운 구조가 된다. 결합력이 낮아져서 가능해진 것
	- 테스트와 마이그레이션 하기 쉽다. 
	- 구현에 있어서 추상화 레이어를 넣고, 이를 기반으로 구현체를 넣어주기 때문에 의존성의 방향이 일관된다.

- 의존성 주입의 단점
	- 모듈들의 분리가 더 많아져서, 클래스의 수가 많아진다. ~~그래서 나같은 초보자한테는 뭐가 어디있는지, 찾기 어려울수도..~~

- 의존성 주입의 원칙
	- "상위 모듈은 하위모듈에서 어떠한 것도 가져올 수 없다."
	- 상위모듈과 하위모듈 둘다 추상화에 의존해야하며, 추상화는 세부사항에 의존하지 말아야한다. 
## 1.1.2 팩토리 패턴

공장을 생각하면 쉽다.
인스턴스 생성을 공장으로 분리한다.

- 인스턴스 생성
- 상위 클래스
	- 뼈대를 결정하고
- 하위 클래스
	- 구체적인 내용을 정의한다.
---
- 상위 클래스와 하위 클래스가 나눠지기에 느슨한 결합을 가진다. 
- 팩토리로 인스턴스 생성을 위임해, 상위클래스에서는 인스턴스의 생성방식에 대해서 알필요가 없어져서 유연하다. 
- 객체 생성이 떨어져 있기 때문에 리팩토링에도 부담이 없다. <- 한 곳만 고치면 되기 때문!

[제대로 이해하는 싱글톤패턴](https://www.youtube.com/watch?v=DHo8qRCtmGU)
## 1.1.3 전략  패턴
제대로 이해한 것인지는 모르겠지만, 예를 들자면 이러하다.

- 책에 있는 예시 1
	- 라인 카드와 카카오 카드로 결제를 하려 한다. 라인 카드와 카카오 카드에 필요한 개인 정보의 종류와 가짓수는 다르다. pay 메소드 자체를 조건을 거는게 아니라, pay 메소드의 파라미터 자체를 "결제방식"으로 추상화 해서 라인카드가 들어가던, 카카오 카드가 들어가던 하게 하는 것이다. 
	```kotlin
	//결제 부
	pay(KAKAOCard("qqq@email.com","qlalfqjsgh"))

	// 함수 구현부
	fun pay(payment: Payment){
	
	}


	//클래스 구현부
	class KAKAOCard : Payment(){
	//이메일, 비밀번호 등
	}
	```
- 내 머리 속에 있는 예시 2
	- 마찬가지로, Oauth도 각 플랫폼 마다 수집할 수 있는 항목이 다르다. apple 로그인에는 일련번호를 알면 이메일을 백엔드 딴에서 알아오는 것으로 되어 있고, 카카오는 바로 일련번호와 이메일을 알아 올 수 있다. 클라이언트 측에서 가져올 수 있는 정보가 다르기에 로그인이라는 메소드를 어느 정도 추상화시키고, 파라미터 자체에 oauth를 상속 받는 kakaoLogin나 naverLogin 등을 넣어주는 것이다.
	```kotlin
	fun login(oauth: Oauth){
	
	}
	
	
	
	//클래스 구현부
	class KAKAOLogin() : Oauth{
	//이메일, 비밀번호 등
	}
```


추상화와 확장성(종류를 늘릴 수 있다.) 단순히 플랫폼의 이름만 다른게 아니라, 수집하는 개인 정보도 다르기에, oauth 플랫폼의 종류를 enum으로 관리하는 것보다 더 나은 것 같다. 

>Enum [이넘]  
>처음 안드로이드를 할 때 카테고리는 이넘 값으로 줄게요~ 했던게 기억이 난다. ㅋㅋㅋ

## 1.1.4 옵저버 패턴
- 주체
- 객체
- 옵저버  

세 개의 등장인물이 등장한다. 

> 주체가 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등의 방식으로 옵저버 목록에 있는 옵저버들 한테 변화를 알리는 것

트위터나 유튜브에서 구독을 하면 해당 유저가 새 글을 올리면 푸쉬 알림을 보내준다. 이러한 것이 Observe!


----

- 자바의 상속과 구현

|  | extends 상속 | implement 구현 |
| ---- | ---- | ---- |
| 기본 | 자식 클래스가 부모 클래스의 변수나 메소드를 상속 받아서 사용한다. 자식 클래스 추가나 확장을 할 수 있다. | 부모 인터페이스를 자식 클래스에서 재정의해서 구현한다. 메소드를 그대로 사용할 수 없다. 반드시 재정의 해야함 |
| 목적 | 재사용성 높이기, 중복성 최소화하기 | 상대적으로 관련성이 없는 클래스들을 묶고 싶을때 |
| 방법 | 일반 클래스, 추상 클래스 | 인터페이스 |

> 그렇다면 코틀린은 상속과 구현을 구분하는가?
> 코틀린의 상속은 `클래스 명(): 상속할 클래스 `이런식으로 한다. 
> 키워드가 아닌 `:`으로 상속을 표현하는데, 상속과 구현을 구분할 수 있을까? 
> 
> -> 결론은 못한다. 그리고 어차피 다중상속이 안된다!
> 	하지만 인터페이스 다중 상속은 가능하다. 목적은 두 인터페이스를 묶는 하나의 클래스를 만드는 용도!


```kotlin
//클래스 구현부
class KAKAOLogin() : Oauth{
//이메일, 비밀번호 등
}
```
책에는 안나와있지만 Kotlin으로 observer 패턴을 알아봐보자


## 1.1.5 프록시 패턴과 프록시 서버
## 1.1.6 이터레이터 패턴
## 1.1.7 노출모듈 패턴
## 1.1.8 MVC 패턴
## 1.1.9 MVP 패턴
## 1.1.10 MVVM 패턴