yaml
- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 


- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟

- 수동으로 조작할 때 사용하는 CLI 도구가 kubectl
- kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
- kubectl은 kubeconfig(기본 위치는 HOME 디렉토리의 .kube/config
- kubectl config 명령으로 수정
kubectl config current-context 
kubectl 명령어 --context 컨텍스트이름
kubectl get pods --context kubernetes-admin@kubernetes
- kubectl run
nginx 파드 생성: kubectl run nginx --image=nginx
리소스(pod) 확인: kubectl get pods
- kubectl create
기본 형식: kubectl create 리소스종류 리소스이름 필요한옵션
kubectl create deployment dpy-nginx --image=nginx
매니페스트를 이용해서 생성: kubectl create -f 매니페스트파일경로(yaml로 작성)
sample-pod.yaml 작성
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
리소스 생성(없을 때는 생성): kubectl create -f sample-pod.yaml
리소스 생성(있을 때는 에러): kubectl create -f sample-pod.yaml
- 리소스 삭제: kubectl delete
형식: kubectl delete 생성할때명령
kubectl 명령은 문법에 맞게 작성을 하고 API Server가 정당한 명령이라고 인식을 하면 완료되었다고 하지만 실제 리소스 처리는 비동기 방식으로 처리가 되기 때문에 리소스 처리가 완료된 상태는 아닐 수 있음
yaml 파일을 작성: sample-pod.yaml
apiVersion: v1
kind: Pod
metadata:
spec:
image: nginx
생성 명령: kubectl create -f sample-pod.yaml
확인: kubectl get pods
삭제 명령이 실제로 처리될 때까지 응답 유보: kubectl delete -f sample-pod.yaml --wait 

- kubectl apply
kubectl apply -f sample-pod.yaml
kubectl apply -f sample-pod.yaml
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: v1
image: nginx:1.17
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl set image pod sample-pod nginx-container=nginx
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
kubectl apply -f sample-pod.yaml
kubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
- 리소스 배포: kubectl apply -f sample-deployment.yaml
- 현재 파드 확인: kubectl get pods
kubectl rollout restart deployment sample-deployment
kubectl rollout restart pod sample-pod 
apiVersion: v1
image: nginx
- 리소스 생성: kubectl create -f sample-generatename.yaml
- 확인: kubectl get pods
kubectl delete all --all
- 리소스가 정상적으로 기동될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=Ready 리소스종류/리소스이름
- 모든 리소스가 스케쥴링 될 때 까지 대기시키고자 하는 경우는 kubectl wait --for=condition=PodScheduled 리소스종류 --all
kubectl create -f sample-pod.yaml
kubectl create -f sample-generatename.yaml
kubectl create -f sample-generatename.yaml
kubectl wait --for=condition=Ready pod/sample-pod
kubectl wait --for=condition=PodScheduled pod --all
kubectl wait --for=delete pod --all --timeout=5s
#모든 파드를 삭제 후 곧바로 kubectl wait를 실행
kubectl delete pod --all --wait=false
kubectl wait --for=delete pod --all
kubectl apply -f sample-pod.yaml
kubectl wait --for=condition=Ready -f sample-pod.yaml
apiVersion: apps/v1
matchLabels:
app: sample-app
metadata:
labels:
app: sample-app
spec:
containers:
- name: nginx-container
image: nginx
apiVersion: v1
protocol: "TCP"
port: 8080
targetPort: 80
app: sample-app
- 리소스 생성: kubectl apply -f sample-multi-resource-manifest.yaml
- 여러 개의 리소스 파일을 한꺼번에 적용하고자 하는 경우는 하나의 디렉토리에 저장한 후 kubectl apply 명령을 할 때 그 디렉토리를 지정하면 되는데 주의할 점은 파일명 순으로 실행되므로 순서대로 실행하고자 하는 경우는 연번의 인덱스 번호를 이용해야 하고 내부에 하위 디렉토리가 있는 경우는 -R 옵션을 추가해 주어야 합니다.
매니페스트 파일 생성: nano dir/sample-pod1.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 생성: nano dir/sample-pod2.yaml
apiVersion: v1
image: nginx:1.17
내부 디렉토리에 매니페스트 파일 생성: nano dir/inner/sample-pod3.yaml
apiVersion: v1
image: nginx:1.17
매니페스트 파일 실행: kubectl apply -f dir, kubectl apply -f  dir -R
Laber				Annotation
kubectl get pods -l 키=값 또는 키
- 쿠버네티스를 실제 운용할 때 수동으로 kubectl 명령어를 실행하는 일은 거의 없는데 수동으로 하면 휴먼 에러의 가능성이 높기 때문에 매니페스트를 git 과 저장소에 저장하고 변경이 있을 때만 kubectl apply 명령을 사용해서 자동으로 매니페스트를 적용시키는 방법을 사용하는 경우가 많음
- kubectl apply 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 사용할 때는 --prune 옵션을 사용
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir
- 현재 상태 확인: kubectl get pods 
- 기존 리소스를 삭제(kubectl delete all --all)하고 sample-pod2.yaml 파일을 dir 디렉토리로 이동(mv sample-pod2.yaml ./dir)
apiVersion: v1
labels:
system: a
image: nginx:1.17
apiVersion: v1
labels:
system: a
image: nginx:1.17
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 리소스를 생성: kubectl apply -f ./dir --prune -l system=a
- 현재 상태 확인: kubectl get pods 
- 기본 형식: kubectl set 변경할정보 리소스종류 리소스이름 실제값
kubectl apply -f sample-pod.yaml
kubectl set image pod sample-pod nginx-container=1.17
kubectl diff -f sample-pod.yaml
- 모든 리소스 종류: kubectl api-resources
- 네임스페이스 수준의 리소스: kubectl api-resources --namespaced=true
- 클러스터 수준의 리소스: kubectl api-resources --namespaced=false
- 리소스 전체 가져오기: kubectl get all
- 특정 리소스 정보만 가져오기: kubectl get 리소스종류
- 하나의 리소스만 가져오기: kubectl get 리소스종류 리소스이름
- 특정 레이블을 가진 리소스 가져오기: kubectl get 리소스종류 label이름=label값
- 노드 목록 표시: kubectl get nodes
kubectl get pods 
kubectl get pods -o yaml #자세히 보기
kubectl get pods -o yaml sample-pod #pod 정보를 yaml 형식으로 보기
kubectl get pods -o custom-columns="NAME:{.metadata.name}, NodeIP:{.status.hostIP}"
kubectl get pods sample-pod -o jsonpath="{.metadata.name}" 
- Metric Server 설치: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl -n kube-system get pods
kubectl top node
kubectl -n kube-system top pod
kubectl -n kube-system top pod --containers
- 배포: kubectl apply -f sample-pod.yaml
- 컨테이너에 접속해서 명령 수행: kubectl exec -it sample-pod -- /bin/ls
- 컨테이너에 명령 수행: kubectl exec -it sample-pod -c nginx-container -- /bin/ls
kubectl port-forward 리소스 외부포트:내부포트
- 파드의 로그 확인: kubectl logs 파드이름
- 컨테이너의 로그 확인: kubectl logs 파드이름 -c 컨테이너이름
kubectl cp 소스 타겟
