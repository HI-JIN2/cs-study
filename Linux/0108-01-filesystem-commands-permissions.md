# Linux

## 1. File System

### 1) 디렉토리 와 파일 관리

- **개요**:

- 우분투 파일 시스템은 파일 과 디렉토리의 계층형 구조(Tree 구조)
- 최상위 루트 디렉토리(/)를 하나 두고 그 아래에 디렉토리나 파일을 배치
- 작업 디렉토리: 우분투에 접속해서 현재 사용하고 있는 디렉토리로 .으로 표시하고 pwd 명령으로 확인
- 상위 디렉토리: 현재 디렉토리를 포함하고 있는 디렉토리로 ..으로 표시
- 홈 디렉토리: 각 사용자에게 할당되는 디렉토리로 사용자 계정을 처음 만들 때 지정가능한데 기본은 /home/계정명 이며 ~ 으로 표시

- 루트에 기본적으로 제공되는 디렉토리

- @이 붙는 경우는 Symbolic Link
bin 과 lib는 유닉스 초창기부터 있던 디렉토리로 지금은 기능이 /usr/bin 과 /usr/lib로 통합되었으나 호환성 유지를 위해서 심볼릭 링크로 만들어 둔 것
- /로 끝나는 것은 디렉토리

/dev: 디바이스 파일
/home: 사용자 별로 할당되는 디렉토리
/media: DVD 나 USB 연결 디렉토리
/etc: 리눅스 설정 파일
/opt: 추가 패키지가 설치되는 디렉토리
/root: root 계정의 홈 디렉토리
/sys: 리눅스 커널 과 관련있는 파일을 저장하는 디렉토리
/usr: 기본 실행 파일과 라이브러리 파일 그리고 헤더 파일이 저장되는 디렉토리
/boot: 부팅에 관련된 커널 파일이 저장된 디렉토리
/lost+found: 파일 시스템에 문제가 발생하여 복구할 경우 문제가 되는 파일이 저장되는 디렉토리
/mnt: 파일을 시스템을 임시로 마운트하는 디렉토리
/proc: 프로세스 정보 등 커널 정보가 저장되는 디렉토리
/run: 실행 중인 서비스와 관련된 파일이 저장되는 디렉토리
/srv: FTP 나 Web 등 시스템에서 제공하는 서비스의 데이터가 저장되는 디렉토리
/tmp: 임시 데이터가 저장되는 디렉토리로 이 디렉토리에 있는 파일은 재시작하면 모두 삭제됨
/var: 시스템 구동 중에 발생하는 데이터나 로그 등 내용이 자주 바뀌는 파일이 저장되는 디렉토리

- 절대 경로 와 상대 경로

- 절대 경로
루트부터 시작하는 경로
/로 시작

- 상대 경로
현재 디렉토리로부터의 경로
. 과 .. 을 이용해서 경로를 만들 수 있음
현재 위치에 따라 달라 질 수 있음

### 2) 파일의 구성 요소

- 리눅스에서 모든 처리 과정은 파일 단위로 이루어지는데 하나의 파일은 파일 이름, i-node, 데이터 블록으로 구성되어 있음

- 파일 이름

- 사용자가 파일을 사용 목적에 맞도록 사용하고 파일에 정확하게 접근할 수 있도록 구별할 수 있는 변별력을 제공
- 모든 운영체제에서 확장자는 선택적     
- 이름 규칙
/는 사용할 수 없음
알파벳, 숫자, .만 가능한데 언어팩을 설치하면 그 언어팩의 문자를 사용할 수 있습니다.
공백이나 몇몇 특수문자는 사용이 불가능
대소문자 구분
리눅스 나 유닉스는 .으로 시작하면 숨김 파일

- **i-node**:

- Index Node라고 불리며 파일을 기술하는 디스크 상에서의 데이터 구조를 의미
- 데이터 블록이 디스크 상의 어디에 위치하는지에 대한 정보를 기록
- 처음 파일을 생성하면 i-node가 0으로 만들어지고 정보를 저장하면 1로 수정
- 저장되는 정보
파일의 종류
파일의 소유권
파일의 엑세스 모드
파일의 타임스탬프

- 데이터 블록

- 실제 데이터가 저장되는 블록

### 3) file

- 파일의 종류를 확인하는 명령

- /usr/share/file 디렉토리의 magic 파일을 참조해서 파일의 종류를 표시

- **형식**:

file [옵션] [파일 및 디렉토리 경로]
- 옵션
C: 파일의 포맷을 검사
f 목록파일: 많은 파일을 한꺼번에 검사할 때 파일 리스트를 만들어서 사용
m 매직파일: 지덩된 매직 파일로 대상 파일을 확인

- file /bin
/bin: symbolic link to usr/bin

- file /usr/bin
/usr/bin: directory

- file /usr/bin/pwd
/usr/bin/pwd: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=29d2c22122c87ddaaf9cecca0e519a312c5be56a, for GNU/Linux 3.2.0, stripped

### 4) 디렉토리 관련 명령

- pwd: 현재 작업 디렉토리를 절대 경로로 출력

- 디렉토리 이동

- cd 명령
- 형식
cd [디렉토리]
- cd 만 입력하면 홈 디렉토리로 이동
- 탭 키 이용 가능

- 디렉토리 내용 확인

- ls 명령
- 형식: ls [옵션] [디렉토리 또는 파일 경로]
- 옵션
a: 숨김 파일을 포함해서 모든 파일을 출력
d: 디렉토리 자체의 정보를 출력
i: 첫번째 행에 i-node 번호를 출력
l: 파일의 상세 정보를 출력
A: . 와 ..을 제외한 모든 모든 파일 과 디렉토리를 출력
F: 파일의 종류를 표시(*: 실행파일, /:디렉토리, @:심볼릭 링크)
L: 심볼릭 링크의 경우 원본 파일의 정보를 출력
R: 하위 디렉토리 목록까지 출력

- 파일의 상세 정보
drwxr-x--- 4 adam adam 4096 Jan  7 08:16 .

맨 앞의 d는 디렉토리 파일이면 -
그 다음 3개의 문자는 파일의 접근 권한인데 소유자의 권한(r: 읽기, w:쓰기, x:실행)
그 다음 3개의 문자는 파일의 접근 권한인데 그룹 사용자의 권한
그 다음 3개의 문자는 파일의 접근 권한인데 기타 사용자의 권한
4는 하드링크의 개수
adam은 소유자
adam은 그룹 
4096은 파일 크기
그 다음은 파일이 마지막으로 수정된 날짜
그 다음은 파일 이름

- ls를 이용한 파일의 존재 여부 확인
ls를 이용하면 파일이 존재하는 경우는 파일의 이름이 출력되지만 그렇지 않은 경우 에러가 표시

- ls 와 비슷한 명령: dir, vdir

- 디렉토리 생성

- 기본적으로 사용자의 홈 디렉토리 하위에만 생성 가능
- /tmp 와 같은 누구에게나 쓰기 권한이 있는 디렉토리도 생성 가능
- 형식: mkdir [옵션] [디렉토리이름]
- 옵션은 p가 있는데 중간 디렉토리가 없는 경우 생성
mkdir temp

mkdir tmp1 tmp2 tmp3

mkdir temp/mid/han => 이 경우  mid 디렉토리가 없어서 에러

mkdir -p temp/mid/han

- 디렉토리 삭제

- 형식: rmdir [옵션] [디렉토리]
- -p 옵션은 하위 디렉토리가 비어 있으면 같이 삭제
rmdir tmp3

rmdir temp => 내부에 하위 디렉토리가 있어서 삭제가 안됨
하위 디렉토리가 있는 경우 디렉토리 삭제 명령이 아니라 파일 삭제 명령으로 삭제

- **실습**:

홈 디렉터리로 이동: cd, cd ~

홈 디렉터리에 linux_ex 디렉터리 생성: mkdir linux_ex

linux_ex 디렉터리 안에 autoever 디렉터리 생성: cd linux_ex -> mkdir autoever, mkdir linux_ex/autoever

autoever 디렉터리 안에 one, two, three 디렉터리를 한 번에 생성: mkdir linux_ex/autoever/one linux_ex/autoever/two linux_ex/autoever/three

one 디렉터리 안에 tmp/test 디렉터리를 생성하는데 중간 디렉터리인 tmp는 자동 생성: mkdir -p linux_ex/autoever/one/tmp/test

rmdir 명령으로 one 디렉터리 삭제: 내부에 /tmp/test 디렉토리가 있어서 one을 바로 삭제하는 것은 되지 않습니다.
rmdir -p  linux_ex/autoever/one/tmp/test
test 디렉토리를 지우고 상위 디렉토리 중 자신을 포함한 디렉토리가 비어 있으면 삭제

two, three 디렉터리를 동시에 삭제: rmdir  linux_ex/autoever/two linux_ex/autoever/three

홈 디렉터리로 이동: cd

### 5) 파일 관련 명령

- **cat**:

- 파일의 내용을 출력해주는 명령
- 형식: cat [옵션] [파일 경로]
- 옵션은 n이 있어서 행 번호 출력
- cat 만 사용하면 키보드 입력 내용을 그대로 출력
- 파일 여러 개 한 꺼번에 출력 가능
- 파일의 내용이 많으면 스크롤을 제공

- **more**:

- 화면 단위로 출력하고 출력할 내용이 더 있으면 화면 하단에 More--(?%) 와 같이 알려줌
- spacebar를 누르면 다음 페이지로 이동하고 b를 누르면 이전 페이지를 출력하고 중단은 q
- /문자열을 입력하면 해당 문자열을 찾아서 이동
- +숫자 옵션을 이용하면 시작할 행 번호 설정 가능
more /etc/services

- **less**:

- more 명령을 개선한 것
- more 명령은 스크롤 기능이 없는데 아래 위 화살표 와 j 나 k를 이용해서 스크롤이 가능
less /etc/services

- **head/tail**:

- 파일의 앞 부분이나 뒷 부분을 출력할 때 사용하는 명령
- 형식: 명령 [옵션] [파일 경로]
- -숫자를 주면 숫자만큼 출력
- tail 명령에서 -f 옵션을 사용하면 실시간으로 추가되는 내용을 확인할 수 있습니다.
- 로그 파일을 화면에 출력할 때 실시간으로 변경 내용을 확인하고자 할 때 tail -f 로그파일경로 를 사용합니다.

- 파일 과 디렉토리 복사

- 형식

```bash
cp [옵션] [파일이나 디렉토리 경로] [파일이나 디렉토리 경로]
```

- 앞의 파일이나 디렉토리를 뒤의 경로에 복사
- 옵션
i: 이미 존재하는 경우 대화식으로 작업
r: 디렉토리 복사할 때 사용
- 옵션없이 복사할 때 이미 존재하는 파일이나 디렉토리라면 덮어씌움
- 여러 개의 파일을 한꺼번에 복사할 수 있는데 이 경우 마지막 경로에 복사가 되는데 반드시 디렉토리 경로 이어야 함

/etc/hosts 파일을 현재 디렉토리의 text1 이라는 파일로 복사: cp /etc/hosts text1

파일을 디렉토리로 복사: cp text1 /tmp

권한이 없는 디렉토리에 복사(복사 실패): cp text1 /etc

여러 개 파일 복사: cp /etc/hosts /etc/services temp

덮어씌기 전에 묻기: cp -i /etc/hosts text1

- 파일 이동 과 파일 이름 변경

- 형식
mv [옵션] [원본파일 및 디렉토리] [이동할 파일 및 디렉토리]

- 옵션
i: 이미 존재하는 경우 대화식으로 이동

- 이름 바꾸기는 현재 경로로 이동
mv text1 data1

- 파일 및 디렉토리 삭제

- 형식
rm [옵션] [파일 또는 디렉토리]
- 옵션
i: 파일을 삭제할 것인지 대화식으로 작업
r: 디렉토리 삭제

rm data1

mkdir -p test/sample

rmdir test # 이 명령으로 test를 삭제할 수 없음 내부에 sample 디렉토리가 존재하기 때문

rm -r test #내부에 파일이나 디렉토리가 있어도 삭제 가능

- **ln**:

- 링크를 생성하는 명령
- 형식
ln [옵션] <링크할 파일> <링크 이름>

- 하드링크
동일한 i-node를 가리키는 파일 이름을 하나 더 생성
한 쪽의 변화가 다른 쪽에 영향을 줍니다.
하나의 파일을 삭제해도 다른 파일은 그대로 남습니다.

```bash
cp /etc/services data1

ls -l #data1의 하드링크는 1
```

ln data1 data1.ln #하드링크 생성

```bash
ls -l #data1의 하드링크는 2
```

- rm 명령은 i-node 나 데이터블럭을 삭제하는 명령이 아닌 하드 링크의 수를 1 감소시키고 하드 링크의 수가 0이 되면 i-node 와 데이터 블럭이 삭제가 됩니다.

```bash
ls -i #하드 링크를 만들면 i-node가 같다는 사실을 확인 
```

- 내용을 수정하면 같이 적용됨
- 하드 링크는 서로 다른 디스크에 생성할 수 없음

- 심볼릭 링크
바로 가기의 역할
링크를 만들 때 -s 옵션을 추가하면 됩니다.

- **touch**:

- 빈 파일을 생성하는 명령
- 형식
touch 파일경로

- **grep**:

- 문자열에서 내용을 검색할 때 사용하는 명령어

- 형식

```bash
grep [옵션][패턴][파일경로]
```

- 옵션
i: 대문자 및 소문자를 모두 검색
l: 지정한 패턴이 포함된 파일명을 출력
n: 행번호 출력
v: 패턴이 포함되지 않은 행을 출력
r: 하위 디렉토리까지 검사
w: 일치하는 단어가 있을 때만 조회
c: 개수

- 실습
```bash
cp /etc/services data #실습을 위해서 파일 복사

grep NNTP data #data 파일에서 NNTP라는 문자열을 검색

grep -r NNTP ~ #홈 디렉토리에서 NNTP가 들어간 모든 파일을 검색
```

- 실행 중인 특정 프로세스 확인
python이 실행 중 인 지 확인: ps -ef | grep "python"

- 현재 실행 중인 포트 확인
```bash
netstat -an | grep "LISTEN"
```

- 실시간으로 수정되는 로그파일(access.log)에서 특정 단어(404) 강조
```bash
tail -f access.log | grep --color "404"
```

- 컨택스트 매핑

| 유형 | 명령 | 설명 |
| --- | --- | --- |
| After | `grep -A 3 "Error" log.txt` | log.txt에서 Error 뒤 3줄 출력 |
| Before | `grep -B 3 "Error" log.txt` | log.txt에서 Error 앞 3줄 출력 |
| Context | `grep -C 3 "Error" log.txt` | log.txt에서 Error 앞뒤 3줄 출력 |

- 정규식 사용 가능
```bash
grep "^Start" file.txt

grep "End$" file.txt

grep "[0-9]" file.txt
```

- **find**:

- 파일을 검색해주는 명령이며 검색 후 동작도 지정 가능
- 형식

```bash
find [경로] [검색 조건] [동작]
```

- 검색 조건
name 파일명
type 파일종류
user 계정
group 그룹
perm 접근권한
size 크기
newer 수정시간
- 동작
exec: 실행
ok: 사용자의 확인을 받아서 실행
print: 절대 경로 명을 출력 - 기본 동작
```bash
ls: 검색 결과를 목록 형식으로 출력
```

- 조건이나 동작이 단어이지만 -만 붙임
- 실습
mkdir -p dir1/doc

touch file-1.txt dir1/doc/file-1.txt

```bash
find . -name '*.txt' -print #현재 디렉토리에서 확장자가 txt 파일을 찾아서 출력
```

- 파일 형식
type f: 파일 검색
type d: 디렉토리 검색
type l: 링크 검색

- 시간으로 검색
```bash
find -newer 파일명: 파일보다 더 최근에 수정된 파일 검색

find -newer "년도-월-일": 년월일 이후에 수정된 파일 검색

find -neweraa "파일명": 더 최근에 접근한 파일 검색

find -newer "파일명1" ! "파일명2": 파일명1 과 파일명2 사이에 수정된 파일 검색
```

- 명령 실행
```bash
find 디렉토리 검색조건 -exec rm {} \; #파일을 찾아서 삭제
```

홈 디렉토리에서 확장자가 swp 인 모든 파일을 삭제
```bash
find ~ -name "*.swp" -exec rm {} \; #파일을 찾아서 삭제
```

- **locate**:

- 파일을 빠르게 찾아주는 명령인데 별도의 패키지를 설치해야 합니다.
- 자체 데이터베이스를 구축해서 검색하므로 빠름

- **wc**:

- 파일이나 표준 입력에서 단어 수, 줄 수, 문자 수 등을 셀 때 사용하는 명령어
- 형식
wc [옵션] [파일경로]
- 옵션
l: 라인 수
w: 단어 수
c: 바이트 수
m: 문자 수
L: 가장 긴 줄의 길이

- **sort**:

- 파일의 내용을 정렬해서 출력
- 형식
sort [옵션][파일 경로]
- 옵션
r: 내림차순
n: 숫자 크기 순으로 정렬
k: 특정 필드를 기준으로 
u: 중복 제거
t: 필드 구분자 지정
M: 월을 기준으로
b: 공백을 무시하고 정렬

- **awk**:

- 텍스트 처리 도구
- 패턴을 기반으로 텍스트 파일, 스트림 및 기타 데이터 형식을 조작하고 처리
- 형식

```bash
awk 옵션 'pattern {action}' file
```

- 옵션
F 구분자

- **sed**:

- 스트림 편집기
- 파일 수정, 텍스트 치환, 라인 삭제 등 다양한 작업에 사용
- 형식

```bash
sed [옵션] 스크립트 [파일경로]
```

- 옵션
n    :  기본 출력을 억제
i    :  파일을 직접 수정
r    :  확장된 정규 표현식 사용
e    :  여러 명령을 순차적으로 실행
f FILE    :  스크립트를 파일에서 읽어오기

### 6) 파일 접근 권한 관리

- **개요**:

- 접근 권한은 파일 가지고 있는 속성 중 하나
- 접근 권한을 확인하는 명령은 ls -l
- 파일이 속한 그룹
사용자는 기본적으로 하나 이상의 그룹에 속하게 되는데 이 그룹을 이용해서 그룹에 속한 사용자들에게만 파일을 공유할 수 있음
사용자가 속한 그룹은 시스템 관리자가 사용자를 등록할 때 결정
그룹은 /etc/group에 정의가 되어 있는데 시스템 관리자만 수정 가능
사용자가 속한 그룹을 확인하는 명령은 groups [사용자명]

- 권한 종류

- 읽기: 파일의 내용을 읽거나 복사할 수 있으며 디렉토리의 경우는 ls 명령으로 디렉토리의 확인할 수 있지만 옵션은 사용안됨
- 쓰기: 파일을 수정, 이동, 삭제할 수 있고 디렉토리 안에 파일을 생성하거나 삭제할 수 있음
- 실행: 파일을 실행할 수 있으며 디렉토리의 경우는 cd 명령으로 이동할 수 있음

- 표기방법
읽기는 r 쓰기는 w 실행은 x 이고 없으면 -

- 접근 권한 변경

- 형식: chmod [옵션] 권한 [파일또는 디렉토리 경로]
- 옵션은 -R이 있는데 하위 디렉토리까지 모두 변경
- 권한 설정 방법
기호모드: 기호를 사용
숫자모드: 8진수 3자리를 이용

- 기호를 이용하는 방법
chmod 사용자카테고리문자 연산자기호 접근권한문자

사용자 카테고리문자
    u: 소유자
    g: 그룹 사용자
    o: 기타 사용자
    a: 전체

연산자 기호
    +: 권한 부여
    -: 권한 제거
    =: 권한 설정

접근권한문자: r, w, x

- 실습
mkdir ex
cd ex

```bash
cp /etc/hosts test.txt    

ls -l #현재 접근 권한은 rw-r--r--(소유자는 읽고 쓰기가 가능하고 그룹 사용자는 읽기만 가능하고 기타 사용자도 읽기만 가능)
```

그룹에 쓰기 와 실행 권한 부여
chmod g+wx test.txt

기타 사용자에게 실행 권한 부여
chmod o+x test.txt

- 숫자를 이용하는 방법
8진수 3자리로 설정
첫번째 자리 4가 읽기
두번째 자리 2가 쓰기
마지막 자리 1일 실행

모든 권한은 7
읽기와 쓰기 권한은 6

- 모든 사용자에게 읽기 권한만 부여
chmod 444 test.txt

- 그룹 사용자에게는 모든 권한을 부여
chmod 474 test.txt

- 기본 접근 권한

- 파일이나 디렉토리를 생성했을 때 주어지는 접근 권한
- 파일을 생성
touch adam.txt
mkdir temp

```bash
ls -l 로 확인
```

파일의 기본 권한 rw-rw-r-- 
디렉토리의 기본 권한 rwxrwxr-x 
- 기본 접근 권한 변경
umask [옵션][마스크값]
- 옵션은 S 인데 마스크 값을 문자로 표현
- mask 확인: umask
- 설정: umask 077(소유자에게만 모든 권한을 부여하고 나머지에게는 아무런 권한도 주지 않음)
- 파일을 만들면 실행 권한은 부여되지 않으므로 스크립트 파일 처럼 실행해야 하는 파일을 만들면 제일 먼저 실행 권한을 부여하는 작업을 해야 합니다.

- 특수 접근 권한

- umask에서 맨 앞자리가 특수 접근 권한
- 0이면 일반적인 접근 권한이고 나머지는 특수접근 권한
SetUID: 4
SetGID: 2
sticky bit: 1

- SetUID
이 파일을 실행하면 해당 파일이 실행되는 동안에는 파일을 실행한 사용자의 권한이 아니라 파일 소유자의 권한이 적용
그러면 x 자리가 s로 나타나게 됩니다.

touch set.exe

chmod 755 set.exe

```bash
ls -l set.exe
```

chmod 4755 set.exe

```bash
ls -l set.exe
```

- sticky bit
누구나 파일을 생성할 수 있는 디렉토리를 만들 때 사용
파일을 생성하면 생성한 계정으로 소유자가 설정되고 다른 사용자가 생성한 파일은 삭제할 수 없습니다.
맨 마지막 권한의 x가 t로 표기가 됩니다.
이러한 대표적인 디렉토리가 /tmp

