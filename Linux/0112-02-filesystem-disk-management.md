# File System & Disk Management

### 1) Linux File System

- 디스크 기반 파일 시스템

- 개요
파일과 디렉토리를 관리하려면 파일 시스템이 필요
리눅스는 초기에 Minix File System(MFS)을 이용했으나 ext 파일 시스템 알려진 리눅스 고유의 파일 시스템을 만들어 사용
ext 파일 시스템은 버전이 계속 업그레이드되면서 현재는 ext4까지 제공하고 있는데 대용량 파일 시스템을 위한 실리콘 그래픽스가 개발한 XFS 파일 시스템도 도입됨

- 종류
ext4
    1EB(1024 * 1024 TB - 1024PB) 이상의 볼륨 과 16TB 이상의 파일을 지원
    디렉토리의 개수도 32000개에서 64000 개로 늘어남
    온라인 조각 모음도 제공

XFS
    eXtended File System은 1993년 실리콘 그래픽스가 개발한 고성능 저널링 파일 시스템
    64비트 파일 시스템으로 16EB까지 지원
    우분투에서 사용하기 위해서는 xfsprogs 라는 패키지가 필요

- 리눅스에서 지원하는 다양한 파일 시스템

- msdos
- iso9660: CDROM 이나 DVD 등의 읽기 전용 파일 시스템
- nfs(Network File System): 원격 서버의 디스크를 연결할 때 사용
- ntfs: 윈도우의 기본 파일 시스템

- 특수 용도의 가상 파일 시스템

- swap
swap 영역을 관리하기 위한 파일 시스템
RAM을 보완하여 부족한 메모리를 디스크 공간으로 확장하고 시스템이 안정적으로 동작하도록 돕는 역할

- tmpfs
Temporary File System으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며 시스템이 재시작할 때 기존 내용이 소멸됨
/tmp 디렉토리

- ramfs
디스크 대신 메모리를 저장 공간처럼 활용하는 가상 파일 시스템
임베디드 장치나 테스트 용도로 사용하는데 tmpfs 와 다른 점은 tmpfs는 메모리를 사용하지만 필요 시 swap을 이용

- rootfs
Root File System으로 시스템 초기화 및 관리에 필요한 내용을 저장

- proc
/proc 디렉토리
커널의 현재 상태를 나타내는 파일을 소유
리눅스의 가상 파일 시스템으로 커널과 프로세스 관련 정보를 사용자 공간에서 확인할 수 있도록 제공
실제 디스크에 저장된 파일이 아니고 메모리에 존재하는 인터페이스
주요 내용
    /proc/cpuinfo - CPU 정보
    /proc/meminfo - 메모리 정보
    /proc/uptime - 부팅 후 경과 시간
    /proc/loadavg - 시스템 평균 부하
    /proc/[PID]/status - 특정 프로세스 상태
    /proc/sys/net/ipv4/ip_forward - 패킷 포워딩 여부

- 현재 시스템에서 지원하는 파일 시스템 확인

```bash
cat /proc/filesystems
```

- 리눅스 파일 시스템

- 유닉스 운영체제에서 유래된 공통의 개념
파일은 inode로 관리
디렉토리는 단순히 파일 목록을 가지고 있는 파일
특수 파일을 통해 장치에 접근

- ext4 파일 시스템의 구조

- 개요
ext4 파일 시스템은 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합으로 구분
일반적으로 블록은 4KB
블록 그룹의 개수는 장치의 크기를 블록 그룹의 크기로 나눈 값 

- inode 구조

- 파일에 대한 정보를 저장한 자료구조
- inode는 크게 두 부분으로 구성되는데 하나는 파일 정보를 저장하는 부분이고 실제 파일 내용이 저장된 데이터 블록의 주소를 저장하는 부분으로 구성
- 파일 정보로는 파일 종류, 파일 접근 권한, 파일 크기, 소유자, 접근 및 수정 시간 등으로 이 정보를 확인하는 방법이 ls -l 입니다.
- 데이터 블록의 주소를 저장하는 부분은 직접 블록, 간접 블록, 이중 간접 블록 등 입니다.

### 2) 리눅스 파일 시스템 과 디렉토리 계층 구조

- 하나의 파일 시스템 구성: 윈도우즈와 다른 점

- 하나의 파일 시스템으로 구성할 경우 /디렉토리에 파일 시스템을 연결
- 윈도우즈는 드라이브(파티션) 별로 파일 시스템을 연결

- 여러 파일 시스템으로 구성은 가능

- 파일 시스템 하나는 /에 연결하고 다른 파일 시스템 하나는 /usr에 연결하는 형태로 구성 가능
- 이런 경우는 여러 개의 디스크나 여러 개의 파티션을 서로 간에 간섭없이 사용하기 위해서 구성

### 3) 파일 시스템 마운트

- **개요**:

- 파일 시스템이 디렉토리 구조와 연결되지 않으면 사용자가 해당 파일 시스템에 접근할 수 없음
- 파일 시스템을 디렉토리 계층 구조의 특정 디렉토리에 연결하는 것을 마운트라고 합니다.

- 마운트 포인트

- 디렉토리 계층 구조에서 파일 시스템이 연결되는 디렉토리

- 파일 마운트 설정 파일

- 리눅스에 시스템이 부팅 될 때 자동으로 파일 시스템이 마운트되게 하려면 /etc/fstab 파일에 관련 사항을 설정
- /etc/fstab 파일의 구조
장치 이름
마운트 포인트
파일 시스템 종류
옵션
덤프 관련 설정
파일 점검 옵션

/dev/disk/by-id/dm-uuid-LVM-wQHgrmPrhB4qpiYeCCz4FD5jqJq2k92dFYPAZHlAUQGKPcX24JF73VkQCZlqKBLu: 장치 이름
/: 루트 디렉토리에 연결 
ext4: 파일 시스템 종류 
defaults: 옵션 
0: 0이면 덤프 명령으로 덤프되지 않은 파일 시스템이고 1이면 데이터 백업 등을 위해 dump 명령의 사용이 가능한 파일 시스템 
1: 0이면 부팅할 때 fsck 명령으로 파일 시스템을 점검하지 않도록 합니다. 1이면 루트 파일 시스템 2이면 루프 파일 이외의 시스템

- 옵션 내용
defaults: 일반적인 파일 시스템 옵션으로 rw, nouser, auto, exec, suid 속성을 포함
auto: 부팅 시 자동으로 마운트
exec: 실행 파일이 실행되는 것을 허용(데이터를 저장하는 것이 목적이라면 제거)
suid: setuid, setgid 의 사용을 허용
ro: 읽기 전용 파일 시스템
rw: 읽기 쓰기 가능한 파일 시스템
user: 일반 사용자도 마운트 가능
nouser: 일반 사용자는 마운트를 할 수 없고 root만 마운트 가능
noauto: 부팅 시 자동으로 마운트하지 않음
noexec: 실행 파일이 실행되는 것을 허용하지 않음
nosuid
usrquota: 사용자 별로 쿼터 설정 가능
grpquota: 그룹 별로 쿼터 설정 가능

- 마운트 관련 명령

- 형식: mount [옵션] [장치명 마운트포인트]

- 옵션
t 파일시스템종류: 파일 시스템 종류를 지정
o 마운트 옵션: 마운트 옵션을 지정
f: 마운트를 할 수 있는지 점검만 수행
r: 읽기만 가능하도록 (-r ro 와 동일)

```bash
mount -t /dev/cdrom /mnt/cdrom: cdrom의 파일 시스템을 /mnt/cdrom으로 마운트
```

- 연결 해제는 unmount 이름

- mount 만 사용하면 /etc/mtab 의 내용을 출력

- 예시
USB 메모리
```bash
    mount /dev/sdc1 /mnt: 리눅스에서 포맷 한 경우
    mount -f vafat /dev/sdc1 /mnt: 윈도우에서 포맷한 경우
```

원격 디스크 마운트
```bash
    mount -f nfs 서버주소:/디렉토리 /mnt
```

- Virtual Box에서 디스크 추가

- Virtual Box를 선택하고 설정을 클릭
- USB를 선택하고 오른쪽 탭에서 [USB 장치 필터]를 추가

- Linux에서 새로운 디스크 사용

- 디스크 확인: sudo fdisk -l
기본 하드디스크가 sda 로 잡히게 되면 새로운 디스크들이 sdb, sdc 등로 설정됩니다.

- 새로운 파티션(물리적 디스크를 운영체제에서 사용할 수 있도록 만든 논리적 공간 - 물리적 디스크는 1개 파티션을 만들어야만 사용이 가능) 생성

```bash
sudo fdisk /dev/sdb 명령을 수행하고 m을 누르면 사용할 수 있는 옵션이 출력됨
```

기존 파티션 삭제: d

새로운 파티션 생성: n

파티션 종류 선택: p

파티션 번호 선택: 1

파티션이 사용하는 디스크의 첫번째 섹터 선택: Enter(맨 앞에서부터)

파티션이 사용하는 디스크의 마지막 섹터 선택: 디스크 크기가 결정

작성을 완료하면 작성한 정보를 저장해야 합니다. : w

- 파티션을 포맷하고 파일 시스템 생성
```bash
sudo mke2fs -t ext4 /dev/sdb1
```

- 파일 시스템 마운트
```bash
sudo mount /dev/sdb1 /mnt
```

- 마운트 해제
```bash
sudo umount /mnt
```

- 디스크 장치의 이름 과 파티션 표시

- 디스크 이름은 컨트롤러에 연결되는 디스크의 순서에 따라 알파벳이 추가
/dev/sda
/dev/sdb
...

- 파티션 이름은 디스크 이름에 숫자를 추가
/dev/sda0
/dev/sda1
/dev/sda2
...

- 파티션 관련 명령: fdisk

- 파티션 관리를 위한 명령

- 형식
fdisk [옵션] [장치명]

- 옵션
b 크기: 섹터 크기 지정
l: 파티션 테이블 조회

- 파티션 생성과 삭제는 옵션없이 장치명을 입력하고 생성이나 삭제를 수행

- 파일 시스템 생성

- 관련 명령은 mkfs 와 mke2fs

- mkfs
mkfs -f 파일시스템종류 파티션

- mke2fs
리눅스 확장 파일 시스템 생성
mke2fs [옵션][파티션]

- 파일 시스템을 생성해야 마운트 가능

### 4) LVM(Logical Volume Manager)

- **개요**:

- 리눅스의 저장 공간을 효율적이고 유연하게 관리하기 위한 커널의 한 부분
- 여러 개의 하드디스크를 합쳐서 한 개의 파티션으로 구성해서 사용할 수 있는 것
- LVM 과 Disk Partitioning
Disk Partitioning은 하드디스크를 파티셔닝 한 후 OS 영역에 마운트해서 read/write를 수행하는이 경우 저장 공간의 크기가 고정되어서 증설/축소가 어려움

LVM은 파티션 대신에 Volume 이라는 단위로 저장 장치를 다루는데 스토리지의 확장, 변경에 유연해서 크기를 변경할 때 기존 데이터의 이전이 필요없음
- 장점
유연한 용량 조절
크기 조절이 가능한 storagge pool
편의에 따른 장치 이름 지정
disk spriping, mirror volume 등을 제공

- 기본 개념

- PV(Physical Volume): 실제 하드디스크의 파티션
- VG(Volume Group):  여러 개의 PV를 그룹으로 묶은 것
- LV(Logical Volume): VG를 다시 적절한 크기의 파티션으로 나눌 때 이 파티션을 LV
- PE(Physical Extent): PV가 가진 일정한 블록
- LE(Logical Extent): LV가 가진 일정한 블록

- 생성 과정

- 기존 파일 시스템 종류 변경: fdisk
- PV 생성: pvcreate
- VG 생성: vgcrate
- VG 활성화: vgchange -a y
- LV 생성: lvcreate
- LV에 파일 시스템 생성: mkfs, mke2fs
- LV 마운트: mount

### 5) 디스크 사용량 확인

- **df**:

- 디스크의 남은 공간에 대한 정보를 출력

- 형식

```bash
df [옵션][파일시스템]
```

- 옵션
a: 모든 파일 시스템을 대상으로 사용량 확인
k: KB 단위
m: MB 단위
h: 알기 쉬운 단위
t 파일시스템종류: 파일 시스템 종류에 맞는 것만 출력
T: 파일 시스템 종류 출력

- **du**:

- 디렉토리나 사용자 별 사용량 확인

- 형식
du [옵션] [디렉토리]

- 옵션
옵션 과 디렉토리 없이 사용하면 현재 디렉토리 정보 출력

s 디렉토리이름: 디렉토리의 사용량을 출력

h: 알기 쉬운 단위와 함께 출력

### 6) 파일 시스템 검사

- 검사: fsck

- 형식: fsck [옵션][장치명]
- 옵션
f: 강제로 점검
b 슈퍼블록: 슈퍼블록으로 지정한 백업 슈퍼블록을 사용
y: 모든 빌문에 yes로 대답
a: 문제가 생긴 경우 자동으로 복구

- 검사: f2fsck

- 형식: f2fsck[옵션][장치명]
- 옵션
f: 강제로 점검
b 슈퍼블록: 슈퍼블록으로 지정한 백업 슈퍼블록을 사용
y: 모든 빌문에 yes로 대답
j: ext3, ext4 파일 시스템을 검사할 때 지정
- 옵션이 없어도 복구 작업 수행

- 배드 블록 검사: badblocks

- 형식: badblocks [옵션][장치명]
- 옵션
v: 검사 결과를 자세하게 출력
o 출력파일: 검사 결과를 파일에 출력
