# Linux

## 1. Linux Booting System

### 1) systemd service

- **개요**:

- 리눅스 시스템의 서비스 관리자로서 유닉스의 init 프로세스가 하던 작업을 대신 수행
- 다양한 서비스 데몬을 시작하고 프로세스 들의 상태를 유지하고 시스템의 상태를 관리
-init 과 관련된 스크립트 파일은 /etc/init.d 디렉토리에 존재: 아직 남아있음
-init 스크립트 방식과 systemd 서비스가 공존

- systemd 가 init 에 비해서 좋은 점

- 소켓 기반으로동작하여 inetd 와 호환성을 유지
- 쉘과 독립적으로 부팅이 가능
- 마운트 제어가 가능
- fsck(File System ChecK) 제어 가능
- 시스템 상태에 대한 스냅샷을 유지
- 서비스에 시그널 전송 가능
- 셧 다운 전에 사용자 세션의 안전한 종료가 가능

- systemd unit

- 유닛 이라는 구성 요소를 사용
- 관리 대상을 서비스이름.유닛종류 형태로 관리
- 종류
service: 시스템 서비스 유닛으로 데몬을 시작, 종료, 재시작 및 로드

target: 유닛을 그룹화
automount: 디렉토리 계층 구조에서 자동 마운트 포인트를 관리
device: 리눅스 장치 트리에 있는 장치를 관리

```bash
mount: 디렉토리 계층 구조에서 마운트 포인트를 관리
```

path: 파일 시스템의 파일이나 디렉토리 경로를 관리
scope: 외부에서 생성된 프로세스를 관리
slice: 시스템의 프로세스를 계층적으로 관리
socket: 소켓을 관리하는 유닛
swap: 스왑 장치 관리
timer: 타이머 와 관련된 기능을 관리

- systemctl 명령

- 형식: systemctl [옵션] [명령] [유닛이름]

- 옵션
a: 상태와 관계없이 유닛 전체를 출력
t 유닛종류: 유닛 종류만 출력

- 명령
start: 유닛 시작 - systemctl start mariadb
stop: 유닛 중지
reload: 유닛의 설정 파일을 다시 읽어옵니다.
restart: 재시작
status: 유닛 상태를 확인
enable: 부팅 시 시작하는 유닛으로 등록
disable: 부팅 시 시작하지 않도록 등록
is-active: 유닛이 동작하고 있는지 확인
is-enabled: 유닛이 시작했는지 확인
isolate: 이 유닛만 시작하고 나머지는 정지
kill: 유닛에 시그널을 전송

- 서비스 등록

- ubuntu에서 서비스를 등록하는 것은 systemd 서비스를 이용하는 것이 일반적
- /etc/systemd/system에 .service 파일을 생성하고 systemctl daemon-reload 그리고 systemctl enable 명령어를 수행해서 서비스를 등록하고 활성화 시킴 
- 파일의 구성

```ini
[Unit]
Description=My custom service
After=network.target

[Service]
ExecStart=/path/to/your/script/myservice.sh
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

[Unit]: 서비스의 메타 데이터와의 의존성을 정의하는데 After=network.target 은 서비스가 시작되기 전에 네트워크 서비스가 먼저 실행되어야 함
[Service]: 실행할 스크립트 파일의 경로 와 실패했을 때 재시작하는 정책을 설정
[Install]: 서비스가 부팅 시 자동으로 시작하도록 하는 분을 정의하는데 WantedBy에 런레벨 설정 가능

- 서비스 등록 및 활성화
서비스 등록

```bash
systemctl daemon-reload # 새로운 서비스 파일을 읽어서 서비스 데몬을 다시 시작
```

서비스 관리 명령을 사용해서 활성화하거나 비활성화

### 2) 종료

- **개요**:

- 리눅스는 대부분 서버 운영체제로 사용되기 때문에 비정상적으로 시스템을 종료해서 문제가 발생하면 서비스를 제공하지 못할 수 있음

- 종료 방법

- shutdown 명령
- halt 명령
- poweroff 명령
- Runlevel을 0이나 6으로 전환
- reboot 명령
- 전원 차단

- **shutdown**:

- 형식: shutdown [옵션] [시간][메시지]
- 옵션
k: 사용자들에게 메시지만 전달
r: 재시작
h: 종료하고 halt 상태로 이동
f: 빠른 재시작  fsck를 수행하지 않음
c: shutdown 명령 취소
- 시간
(hh:mm, now, +분)

- now를 사용하면 즉시 종료
- k 나 h 옵션을 사용하면 메시지만 전송하고 종료되지 않음

- Run Level을 변경해서 종료하는 것도 가능

```bash
sudo init 0 또는 sudo init 6
```

- 종료
```bash
sudo systemctl isolate poweroff.target
sudo systemctl isolate runlevel0.target
```

- 재시작
```bash
sudo systemctl isolate reboot.target
sudo systemctl isolate runlevel6.target
```

- 종료의 다른 명령: systemctl 명령의 심볼릭 링크

- halt: /sbin/halt
- poweroff: /sbin/poweroff
- reboot: /sbin/reboot

### 3) Daemon Process

- **개요**:

- 리눅스의 백그라운드에서 동작하며 특정한 서비스를 제공하는 프로세스
- 서버로 사용되는 프로세스들이 대부분 데몬
- 데몬 혼자서 스스로 동작하는 독자형 과 데몬을 관리하는 슈퍼 데몬에 의해 동작하는 방식이 있음
- 독자형의 경우 시스템의 백그라운드에서 항상 동작하고 있는데 자주 호출되는 데몬이 아니라면 시스템의 자원을 낭비할 우려가 있음
- 슈퍼 데몬에 의한 동작 방식은 평소에는 슈퍼 데몬만 동작하다가 서비스 요청이 오면 슈퍼 데몬이 해당 데몬을 동작시키는 것으로 독자형보다는 서비스에 응답하는데 시간이 좀 더 걸릴 수 있지만 자원을 효율적으로 사용하는 것이 가능

- 슈퍼 데몬

- 데몬의 종류가 늘어나자 이를 관리하기 위해서 등장
- 유닉스의 슈퍼 데몬이 inetd 였는데 우분투에서는 보안 기능이 포함된 xinetd를 사용
- 슈퍼 데몬은 네트워크 서비스를 제공하는 데몬만 관리
- 사용자가 네트워크 서비스를 요청하면 슈퍼 데몬이 이를 받아서 해당하는 서비스 데몬을 동작시키는 것

- systemd 데몬

- init을 대체한 데몬
- 대다수 프로세스의 조상 프로세스
- pstree 명령으로 확인 가능

- kernel thread 데몬

- 커널 일부분을 프로세스 처럼 관리하는 데몬
- ps 명령으로 확인할 때 [ ] 에 들어있는 프로세스들
- 커널 데몬은 대부분 입출력이나 메모리 관리 그리고 디스크 동기화등을 수행하고 낮은 번호의 PID를 가짐

- 주요 데몬

- atd: 특정 시간에 실행되도록 예약한 명령을 실행하도록 해주는 데몬
- cron: 주기적으로 실행되도록 예약한 명령을 실행하도록 해주는 데몬
- dhcpd: 동적 IP 주소 할당
- httpd: 웹 서버
- nfs: 네트워크 파일 시스템 서비스 제공
- named: DNS
- sendmail: 메일 전송 데몬
- smtpd: 메일 전송 데몬
- popd: 기본 메일 서비스
- routed: 자동 IP 라우터 테이블 제공
- smb: 삼바 서비스를 제공
- syslogd: 로그 기록 서비스를 제공
- sshd: 원격 보안 서비스를 제공
- ftpd: 파일 송수신 서비스
- ntpd: 시간 동기화 서비스

### 4) Boot Loader

- **개요**:

- 커널을 메모리에 로딩하는 역할을 수행
- 리눅스에서는 LILO 와 GRUB 라는 두 가지 부트 로더가 있는데 우분투에서는 GRUB를 사용
- GRUB(GRand Unified Bootloader)의 약자로 리눅스의 전통적인 부트 로더인 LILO의 단점을 보완한 것임
- GRUB가 LILO에 비해 가진 장점
LILO는 리눅스에서만 사용할 수 있지만 GRUB는 윈도우에서도 사용할 수 있음
LILO에 비해 설정과 사용이 편리
부팅할 때 명령을 사용하여 수정할 수 있음
멀티 부팅 기능을 제공
- 최신 버전은 GRUB2 입니다.

- 관련 디렉토리 와 파일

- /boot/grub/grub.cfg
직접 수정 불가
이 파일이 /etc/defaul/grub 파일 과 /etc/grub.d 디렉토리 아래에 있는 스크립트를 읽어서 생성
파일의 내용을 수정하고자 하는 경우는 위의 파일 과 디렉토리 안에 있는 파일을 수정

- /etc/grub.d 디렉토리
GRUB 관련 스크립트를 가지고 있음

- /etc/defaul/grub 파일
GRUB 메뉴 설정 내용이 저장되어 있음

- 루트 계정의 암호를 잃어버린 경우

- GRUB 메뉴 초기 화면을 출력
- 메뉴 초기 화면에서 E를 눌러서 편집 모드로 전환한 후 커서를 아래로 내려서 ro splach vt_handoff 부분을 rw init=/bin/bash로 수정
- 재부팅하면 비밀번호 없이 root 계정으로 로그인

### 5) Namespace & Cgroup

- Container 기술

- 애플리케이션을 효율적이고 독립적으로 실행할 수 있는 경량화된 환경을 제공
- 컨테이너 기술의 근간이 되는 리눅스 기술
Control Group(Cgroup)
Namespace
Union Mount Filesystem

- Control Group

- 프로세스들이 사용하는 시스템 자원의 사용 정보를 수집 및 제한시키는 커널의 기늘
- 사용 가능한 서브 시스템
CPU
Memory
Freezer: cgroup의 작업을 일시 중지하거나 다시 시작
blkio: 블록 장치에 대한 I/O를 제한
net_cls: 트래픽 컨트롤러가 특정 cgroup 작업에서 발생하는 패킷을 식별하게 하는 네트워크 패킷 태그를 지정
cpuset: 개별 CPU 메모리 노드를 cgroup에 할당
cpuacct: CPU 자원 보고서 생성
devices: cgroup의 작업 단위
ns: namespace 서브 시스템

- **Namespace**:

- 프로세스를 격리하기 위해 사용하는 커널의 기능
- Docker 와 같은 컨테이너 기술의 핵심 기반

## 2. File System & Disk Management

### 1) Linux File System

- 디스크 기반 파일 시스템

- 개요
파일과 디렉토리를 관리하려면 파일 시스템이 필요
리눅스는 초기에 Minix File System(MFS)을 이용했으나 ext 파일 시스템 알려진 리눅스 고유의 파일 시스템을 만들어 사용
ext 파일 시스템은 버전이 계속 업그레이드되면서 현재는 ext4까지 제공하고 있는데 대용량 파일 시스템을 위한 실리콘 그래픽스가 개발한 XFS 파일 시스템도 도입됨

- 종류
ext4
    1EB(1024 * 1024 TB - 1024PB) 이상의 볼륨 과 16TB 이상의 파일을 지원
    디렉토리의 개수도 32000개에서 64000 개로 늘어남
    온라인 조각 모음도 제공

XFS
    eXtended File System은 1993년 실리콘 그래픽스가 개발한 고성능 저널링 파일 시스템
    64비트 파일 시스템으로 16EB까지 지원
    우분투에서 사용하기 위해서는 xfsprogs 라는 패키지가 필요

- 리눅스에서 지원하는 다양한 파일 시스템

- msdos
- iso9660: CDROM 이나 DVD 등의 읽기 전용 파일 시스템
- nfs(Network File System): 원격 서버의 디스크를 연결할 때 사용
- ntfs: 윈도우의 기본 파일 시스템

- 특수 용도의 가상 파일 시스템

- swap
swap 영역을 관리하기 위한 파일 시스템
RAM을 보완하여 부족한 메모리를 디스크 공간으로 확장하고 시스템이 안정적으로 동작하도록 돕는 역할

- tmpfs
Temporary File System으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며 시스템이 재시작할 때 기존 내용이 소멸됨
/tmp 디렉토리

- ramfs
디스크 대신 메모리를 저장 공간처럼 활용하는 가상 파일 시스템
임베디드 장치나 테스트 용도로 사용하는데 tmpfs 와 다른 점은 tmpfs는 메모리를 사용하지만 필요 시 swap을 이용

- rootfs
Root File System으로 시스템 초기화 및 관리에 필요한 내용을 저장

- proc
/proc 디렉토리
커널의 현재 상태를 나타내는 파일을 소유
리눅스의 가상 파일 시스템으로 커널과 프로세스 관련 정보를 사용자 공간에서 확인할 수 있도록 제공
실제 디스크에 저장된 파일이 아니고 메모리에 존재하는 인터페이스
주요 내용
    /proc/cpuinfo - CPU 정보
    /proc/meminfo - 메모리 정보
    /proc/uptime - 부팅 후 경과 시간
    /proc/loadavg - 시스템 평균 부하
    /proc/[PID]/status - 특정 프로세스 상태
    /proc/sys/net/ipv4/ip_forward - 패킷 포워딩 여부

- 현재 시스템에서 지원하는 파일 시스템 확인

```bash
cat /proc/filesystems
```

- 리눅스 파일 시스템

- 유닉스 운영체제에서 유래된 공통의 개념
파일은 inode로 관리
디렉토리는 단순히 파일 목록을 가지고 있는 파일
특수 파일을 통해 장치에 접근

- ext4 파일 시스템의 구조

- 개요
ext4 파일 시스템은 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합으로 구분
일반적으로 블록은 4KB
블록 그룹의 개수는 장치의 크기를 블록 그룹의 크기로 나눈 값 

- inode 구조

- 파일에 대한 정보를 저장한 자료구조
- inode는 크게 두 부분으로 구성되는데 하나는 파일 정보를 저장하는 부분이고 실제 파일 내용이 저장된 데이터 블록의 주소를 저장하는 부분으로 구성
- 파일 정보로는 파일 종류, 파일 접근 권한, 파일 크기, 소유자, 접근 및 수정 시간 등으로 이 정보를 확인하는 방법이 ls -l 입니다.
- 데이터 블록의 주소를 저장하는 부분은 직접 블록, 간접 블록, 이중 간접 블록 등 입니다.

### 2) 리눅스 파일 시스템 과 디렉토리 계층 구조

- 하나의 파일 시스템 구성: 윈도우즈와 다른 점

- 하나의 파일 시스템으로 구성할 경우 /디렉토리에 파일 시스템을 연결
- 윈도우즈는 드라이브(파티션) 별로 파일 시스템을 연결

- 여러 파일 시스템으로 구성은 가능

- 파일 시스템 하나는 /에 연결하고 다른 파일 시스템 하나는 /usr에 연결하는 형태로 구성 가능
- 이런 경우는 여러 개의 디스크나 여러 개의 파티션을 서로 간에 간섭없이 사용하기 위해서 구성

### 3) 파일 시스템 마운트

- **개요**:

- 파일 시스템이 디렉토리 구조와 연결되지 않으면 사용자가 해당 파일 시스템에 접근할 수 없음
- 파일 시스템을 디렉토리 계층 구조의 특정 디렉토리에 연결하는 것을 마운트라고 합니다.

- 마운트 포인트

- 디렉토리 계층 구조에서 파일 시스템이 연결되는 디렉토리

- 파일 마운트 설정 파일

- 리눅스에 시스템이 부팅 될 때 자동으로 파일 시스템이 마운트되게 하려면 /etc/fstab 파일에 관련 사항을 설정
- /etc/fstab 파일의 구조
장치 이름
마운트 포인트
파일 시스템 종류
옵션
덤프 관련 설정
파일 점검 옵션

/dev/disk/by-id/dm-uuid-LVM-wQHgrmPrhB4qpiYeCCz4FD5jqJq2k92dFYPAZHlAUQGKPcX24JF73VkQCZlqKBLu: 장치 이름
/: 루트 디렉토리에 연결 
ext4: 파일 시스템 종류 
defaults: 옵션 
0: 0이면 덤프 명령으로 덤프되지 않은 파일 시스템이고 1이면 데이터 백업 등을 위해 dump 명령의 사용이 가능한 파일 시스템 
1: 0이면 부팅할 때 fsck 명령으로 파일 시스템을 점검하지 않도록 합니다. 1이면 루트 파일 시스템 2이면 루프 파일 이외의 시스템

- 옵션 내용
defaults: 일반적인 파일 시스템 옵션으로 rw, nouser, auto, exec, suid 속성을 포함
auto: 부팅 시 자동으로 마운트
exec: 실행 파일이 실행되는 것을 허용(데이터를 저장하는 것이 목적이라면 제거)
suid: setuid, setgid 의 사용을 허용
ro: 읽기 전용 파일 시스템
rw: 읽기 쓰기 가능한 파일 시스템
user: 일반 사용자도 마운트 가능
nouser: 일반 사용자는 마운트를 할 수 없고 root만 마운트 가능
noauto: 부팅 시 자동으로 마운트하지 않음
noexec: 실행 파일이 실행되는 것을 허용하지 않음
nosuid
usrquota: 사용자 별로 쿼터 설정 가능
grpquota: 그룹 별로 쿼터 설정 가능

- 마운트 관련 명령

- 형식: mount [옵션] [장치명 마운트포인트]

- 옵션
t 파일시스템종류: 파일 시스템 종류를 지정
o 마운트 옵션: 마운트 옵션을 지정
f: 마운트를 할 수 있는지 점검만 수행
r: 읽기만 가능하도록 (-r ro 와 동일)

```bash
mount -t /dev/cdrom /mnt/cdrom: cdrom의 파일 시스템을 /mnt/cdrom으로 마운트
```

- 연결 해제는 unmount 이름

- mount 만 사용하면 /etc/mtab 의 내용을 출력

- 예시
USB 메모리
```bash
    mount /dev/sdc1 /mnt: 리눅스에서 포맷 한 경우
    mount -f vafat /dev/sdc1 /mnt: 윈도우에서 포맷한 경우
```

원격 디스크 마운트
```bash
    mount -f nfs 서버주소:/디렉토리 /mnt
```

- Virtual Box에서 디스크 추가

- Virtual Box를 선택하고 설정을 클릭
- USB를 선택하고 오른쪽 탭에서 [USB 장치 필터]를 추가

- Linux에서 새로운 디스크 사용

- 디스크 확인: sudo fdisk -l
기본 하드디스크가 sda 로 잡히게 되면 새로운 디스크들이 sdb, sdc 등로 설정됩니다.

- 새로운 파티션(물리적 디스크를 운영체제에서 사용할 수 있도록 만든 논리적 공간 - 물리적 디스크는 1개 파티션을 만들어야만 사용이 가능) 생성

```bash
sudo fdisk /dev/sdb 명령을 수행하고 m을 누르면 사용할 수 있는 옵션이 출력됨
```

기존 파티션 삭제: d

새로운 파티션 생성: n

파티션 종류 선택: p

파티션 번호 선택: 1

파티션이 사용하는 디스크의 첫번째 섹터 선택: Enter(맨 앞에서부터)

파티션이 사용하는 디스크의 마지막 섹터 선택: 디스크 크기가 결정

작성을 완료하면 작성한 정보를 저장해야 합니다. : w

- 파티션을 포맷하고 파일 시스템 생성
```bash
sudo mke2fs -t ext4 /dev/sdb1
```

- 파일 시스템 마운트
```bash
sudo mount /dev/sdb1 /mnt
```

- 마운트 해제
```bash
sudo umount /mnt
```

- 디스크 장치의 이름 과 파티션 표시

- 디스크 이름은 컨트롤러에 연결되는 디스크의 순서에 따라 알파벳이 추가
/dev/sda
/dev/sdb
...

- 파티션 이름은 디스크 이름에 숫자를 추가
/dev/sda0
/dev/sda1
/dev/sda2
...

- 파티션 관련 명령: fdisk

- 파티션 관리를 위한 명령

- 형식
fdisk [옵션] [장치명]

- 옵션
b 크기: 섹터 크기 지정
l: 파티션 테이블 조회

- 파티션 생성과 삭제는 옵션없이 장치명을 입력하고 생성이나 삭제를 수행

- 파일 시스템 생성

- 관련 명령은 mkfs 와 mke2fs

- mkfs
mkfs -f 파일시스템종류 파티션

- mke2fs
리눅스 확장 파일 시스템 생성
mke2fs [옵션][파티션]

- 파일 시스템을 생성해야 마운트 가능

### 4) LVM(Logical Volume Manager)

- **개요**:

- 리눅스의 저장 공간을 효율적이고 유연하게 관리하기 위한 커널의 한 부분
- 여러 개의 하드디스크를 합쳐서 한 개의 파티션으로 구성해서 사용할 수 있는 것
- LVM 과 Disk Partitioning
Disk Partitioning은 하드디스크를 파티셔닝 한 후 OS 영역에 마운트해서 read/write를 수행하는이 경우 저장 공간의 크기가 고정되어서 증설/축소가 어려움

LVM은 파티션 대신에 Volume 이라는 단위로 저장 장치를 다루는데 스토리지의 확장, 변경에 유연해서 크기를 변경할 때 기존 데이터의 이전이 필요없음
- 장점
유연한 용량 조절
크기 조절이 가능한 storagge pool
편의에 따른 장치 이름 지정
disk spriping, mirror volume 등을 제공

- 기본 개념

- PV(Physical Volume): 실제 하드디스크의 파티션
- VG(Volume Group):  여러 개의 PV를 그룹으로 묶은 것
- LV(Logical Volume): VG를 다시 적절한 크기의 파티션으로 나눌 때 이 파티션을 LV
- PE(Physical Extent): PV가 가진 일정한 블록
- LE(Logical Extent): LV가 가진 일정한 블록

- 생성 과정

- 기존 파일 시스템 종류 변경: fdisk
- PV 생성: pvcreate
- VG 생성: vgcrate
- VG 활성화: vgchange -a y
- LV 생성: lvcreate
- LV에 파일 시스템 생성: mkfs, mke2fs
- LV 마운트: mount

### 5) 디스크 사용량 확인

- **df**:

- 디스크의 남은 공간에 대한 정보를 출력

- 형식

```bash
df [옵션][파일시스템]
```

- 옵션
a: 모든 파일 시스템을 대상으로 사용량 확인
k: KB 단위
m: MB 단위
h: 알기 쉬운 단위
t 파일시스템종류: 파일 시스템 종류에 맞는 것만 출력
T: 파일 시스템 종류 출력

- **du**:

- 디렉토리나 사용자 별 사용량 확인

- 형식
du [옵션] [디렉토리]

- 옵션
옵션 과 디렉토리 없이 사용하면 현재 디렉토리 정보 출력

s 디렉토리이름: 디렉토리의 사용량을 출력

h: 알기 쉬운 단위와 함께 출력

### 6) 파일 시스템 검사

- 검사: fsck

- 형식: fsck [옵션][장치명]
- 옵션
f: 강제로 점검
b 슈퍼블록: 슈퍼블록으로 지정한 백업 슈퍼블록을 사용
y: 모든 빌문에 yes로 대답
a: 문제가 생긴 경우 자동으로 복구

- 검사: f2fsck

- 형식: f2fsck[옵션][장치명]
- 옵션
f: 강제로 점검
b 슈퍼블록: 슈퍼블록으로 지정한 백업 슈퍼블록을 사용
y: 모든 빌문에 yes로 대답
j: ext3, ext4 파일 시스템을 검사할 때 지정
- 옵션이 없어도 복구 작업 수행

- 배드 블록 검사: badblocks

- 형식: badblocks [옵션][장치명]
- 옵션
v: 검사 결과를 자세하게 출력
o 출력파일: 검사 결과를 파일에 출력
