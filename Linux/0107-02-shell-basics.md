# Shell

## 1. Shell

### 1) 개요

- 사용자가 입력한 명령을 해석해서 커널로 전달하거나 커널의 처리 결과를 사용자에게 전달하는 역할을 수행

- Server의 텍스트 모드나 X 윈도(GUI)의 터미널처럼 명령을 입력하는 인터페이스

- **기능**:

- 명령어 해석기
- 프로그래밍
자체 내에 프로그래밍 기능이 있어서 프로그래밍이 가능(Shell Programming)

여러 명령을 사용하여 반복적으로 수행하는 작업을 하나의 프로그램으로 만들 수 있는데 이를 Shell Script 라고 합니다.
- 사용자 환경 설정
사용자 환경을 설정할 수 있도록 초기화 파일 기능을 제공
초기화 파일에 명령을 찾아오는 경로를 설정하거나 파일 과 디렉토리를 새로 생성할 대 적용하는 기본 권한을 설정하거나 다양한 환경 변수 등을 설정하는 것이 가능
사용자가 로그인을 할 때 이 초기화 파일이 실행되어 사용자 별로 특성에 맞게 초기 환경이 설정됨

### 2) 종류

- 본쉘(sh): 최초의 쉘, 지금은 배시쉘로 대체

- C쉘(csh): 2BSD 유닉스에서 발표

- 콘쉘(ksh): AT&T에서 개발해서 SVR4 유닉스에서 발표

- **bsh**:

- 본 쉘과 호환성 유지하고 C쉘 과 콘쉡의 편리한 기능 모두 포함
- 리눅스의 기본 쉘로 제공

- tsch: csh에 이어서 개발된 C쉘 계열의 쉘

- dash shell

- 본쉘을 기반으로 개발, 작은 크기로 개발

- **zsh**:

- 최근에 개발된 쉘로 bash 와 tsch의 기능에 독작적인 기능을 추가
- 다양한 기능을 제공

### 3) login shell & sub shell

- **개요**:

- login shell은 리눅스에 접속했을 때 보여지는 쉘
- 사용자가 프롬프트에서 다른 쉘을 실행할 수 있는데 이 쉘이 서브 쉘
- 쉘을 종료하는 명령은 CTRL + d 또는 exit
- 서브 쉘이 종료되면 이전 쉘 환경으로 돌아가지만 로그인 쉘을 종료하면 터미널이 종료되거나 원격접속이 해제 됩니다.

### 4) bash shell

- 우분투에서 기본적으로 제공하는 쉘

- **특징**:

- alias 기능 제공
- history 기능 제공
- 연산 기능 제공
- Job Control 기능 제공
- 자동 완성 기능 제공
- 프롬프트 제어 기능
- 명령 편집 기능

### 5) 지원하는 shell 확인

- 지원하는 shell은 /etc/shells 파일에 기재

- cat 명령을 사용하면 텍스트 파일의 내용을 화면에 출력

### 6) shell 변경

- 사용자의 로그인 쉘 확인

- /etc/passwd 파일에 기록이 되어 있음
- grep adam /etc/passwd 으로 확인(adam 자리는 자신의 계정)

- C shell 설치

- sudo apt install csh
- 확인: cat /etc/shells

- 쉘 변경 명령

chsh [옵션] [사용자계정]

- 옵션
-s shell경로: 지정하는 쉘로 로그인 쉘로 변경, 쉘의 경로를 절대경로로 설정해야 함
-l: /etc/shells 파일에 지정된 쉘을 출력

- 절대 경로 와 상태 경로
절대 경로: 루트로부터의 경로로 불변(Windows는 드라이브이름:\로 시작하는데 나머지 운영체제는 /로 시작)
상대 경로: 현재 위치로부터의 경로(./는 현재 디렉토리를 나타내는 것인데 생략해도 가능하고 ../가 상위 디렉토리를 의미)

- 쉘을 변경한 경우 다시 접속해야 반영됩니다.

- adam 계정의 로그인 쉘을 csh로 수정
chsh -s /bin/csh adam #exit로 쉘을 종료하고 다시 접속해야 확인 가능

chsh -s /bin/bash adam

- 쉘이름 -s sh 사용자계정
위 명령으로도 쉘 변경이 가능

### 7) 쉘 내장명령

- 쉘은 자체적으로 내장 명령을 가지고 있는데 일반적인 리눅스 명령들이 /bin 이나 /usr/bin 디렉토리에 별도의 실행파일로 존재하는 것 과 달리 별도의 실행 파일 없이 쉘 안에 내장되어 있습니다.

- cd는 쉘 내장명령

- pwd 명령 확인: file /usr/pwd 했을 때 내용이 확인 됩니다.
- cd 명령 확인: file cd, file /bin/cd, file /usr/bin/cd 모두 확인이 불가능

- 출력 명령

- echo
화면에 한 줄의 문자열을 출력

형식: echo [-n] [문자열 또는 변수]
-n을 추가하면 마지막에 줄 바꿈 안함

- printf
데이터를 형식화해서 출력할 때 사용
형식: printf [서식][데이터]
서식은 %d 나 \n 과 같은 C언어의 printf 함수의 형식을 지정

printf linux

printf "ubuntu linux \n"

printf "%d + %d = %d\n" 1 3 4

### 8) 특수문자

- **개요**:

- 편리하게 명령을 입력하고 실행할 수 있도록 다양한 특수 문자를 제공
- 특수문자의 사용법은 거의 모든 쉘에서 비슷
- 사용자가 명령을 입력하면 쉘은 먼저 입력한 내용 중에 특수 문자가 있는지 확인하고 이를 해독해서 적절한 형태로 변경한 후 명령을 실행

*****

글자 수 상관없이 모든 문자 또는 문자열을 의미

- ls *: 모든 디렉토리의 내용을 출력
- cp * /tmp: 현재 디렉토리의 모든 내용을 /tmp에 복사
- ls -F t*: t로 시작하는 모든 디렉토리의 내용을 확인

- **?**: 하나의 글자와 매칭

```bash
ls t??: t로 시작하는 3글자
```

- [ ]

대괄호 안의 문자 하나와 매칭

```bash
ls -l tmp[1 3 5].txt: tmp1.txt, tmp3.txt, tmp5.txt
```

- - 범위

a-z: 소문자

```bash
ls [A-Za-z][0-9]: 영문으로 시작하고 두번째 글자는 숫자
```

한글은 [가-힣]

- **~**:

- 사용자의 홈 디렉토리를 의미하는 특수문자

- **-**:

- 현재 디렉토리로 이동하기 직전의 디렉토리

- **`(백틱)**:

- 문자열에서 명령을 수행해서 명령의 결과로 대체

- Today is 오늘날짜 출력

```bash
echo "Today is date"     : date라는 글자를 출력
echo "Today is `date`"    : date라는 명령을 수행해서 출력
```

- **;**:

- 여러 개의 명령을 순차적으로 실행할 때 사용하는데 앞의 명령어가 실패해도 다음 명령어를 수행
- date 와 ls 그리고 pwd 명령을 순차적으로 전부 수행

```bash
date; ls; pwd
```

- **&&**:

- 여러 개의 명령을 순차적으로 실행할 때 사용하는데 앞의 명령어가 성공해야만 다음 명령어를 수행

```bash
date&& ls&& pwd
```

- **|**:

- 앞의 명령의 결과를 가지고 뒤의 명령을 수행
- 앞의 명령이 출력일 때 그 안에서 검색을 하는 경우 많이 사용하고 앞의 내용을 출력할 때 내용이 너무 많은 경우 more 같은 명령으로 페이지 단위로 출력되도록 할 때 많이 사용

```bash
ls -al / | more
```

- **\**:

- 특수 문자의 효과 무력화

```bash
ls t\* : t* 이라는 이름의 파일이나 디렉토리를 조회
echo \$SHELL: $SHELL 이라는 글자를 출력
```

- ' ' 와 " "

- ' ' 안에 명령어를 기재하면 모든 특수문자의 기능 무력화
- " " 안에 명령어를 기재하면 달러 기호(변수 치환), 백슬래시, 중괄호 표기는 원래대로 처리

### 9) 표준 입출력 장치

- **정의**:

파일디스크립터        파일디스크립터 대신 사용하는 이름        정의
0            stdin                    표준 입력 - 기본은 키보드
1            stdout                    표준 출력 - 기본은 모니터
2            stderr                    표준 에러 - 기본은 모니터

- 출력 리다이렉션: 출력의 방향을 변경하는 것

- >
    출력 방향을 변경하는 것으로 출력 방향의 모든 것을 지우고 출력
    형식
        명령 1 > 경로
        명령 > 경로

```bash
    date > date1.txt
    cat date1.txt
    ls -F / > date1.txt
    cat date1.txt        #기존 내용이 사라지고 새로운 내용이 조회
```

- >>
    출력 방향을 변경하는 것으로 출력 방향의 뒤에 출력

```bash
    date >> date2.txt
    cat date2.txt
    ls -F / >> date2.txt
    cat date2.txt
```

- 에러 리다이렉션

- 2>

    명령 2> 출력경로 를 이용하면 에러가 발생했을 때 에러 내용을 리다이렉션 합니다.

```bash
    ls abc 2> ls.err
```

- 에러 메시지 버리기
```bash
    ls abc 2> /dev/null
```

- 표준 출력 과 에러를 하나의 파일에 기록
```bash
ls abc > ls.out 2>&1
```

- 입력 리다이렉션

- 표준 입력은 키보드지만 표준 입력의 경로를 변경하는 것
- 형식
명령 0<  경로
명령 < 경로

- 파일의 내용을 가지고 명령의 매개변수를 만들 때 많이 이용

### 10) 변수

- **종류**:

- SHELL 변수: 현재 SHELL에서만 사용 가능한 변수
- 환경 변수: 시스템 전체에 적용되는 변수

- 변수 확인

```bash
echo $변수이름
env
set
```

- 변수 수정

- SHELL 변수 생성 및 수정: 변수이름=값
공백이 있으면 안됨
HYUNDAE=AUTOEVER

- 환경 변수 생성 및 수정: export 변수명=값
export HYUNDAE=AUTOEVER

- 환경 변수를 로컬 변수로 수정: export -n 변수명
export -n HYUNDAE 

- 변수 삭제: unset 변수명
unset HYUNDAE

- 프롬프트 설정

- PS1 이라는 환경 변수를 이용해서 가능

- **PATH**:

- 명령어의 위치를 찾는 디렉토리를 저장하고 있는 변수

- 명령어를 찾을 위치를 :으로 구분해서 설정

- 추가하는 방법
```bash
PATH="$PATH:경로"
PATH="경로:$PATH"
```

- 리눅스에서는 프로그램을 설치할 때 압축 파일을 다운로드 받아서 압축을 해제하는 것만으로 하는 경우가 있습니다.
이 때 압축이 해제된 디렉토리의 실행 파일을 명령어 만으로 실행하고자 하는 경우 이를 구현하는 방법은 전체 경로를 alias 로 만들어서 사용해도 되고 전체 경로를 PATH에 추가해도 되고 PATH에 추가된 디렉토리에 실행하고자 하는 명령어 나 파일을 복사해도 됩니다.

- 홈 디렉토리 안의 bin 이라는 디렉토리를 PATH에 추가

```bash
# 기존 환경 변수의 값을 다른 변수에 복사
adam@basic:~$ OLDPATH=$PATH

# 환경 변수 편집을 수행했는데 잘못 편집 - :을 추가해야 하는데 ;을 추가
adam@basic:~$ PATH="$PATH;~/bin"
adam@basic:~$ echo $PATH

# 원래 값을 복원하고 다시 수행
adam@basic:~$ PATH=$OLDPATH
adam@basic:~$ echo $PATH
adam@basic:~$ PATH="$PATH:~/bin"
adam@basic:~$ echo $PATH
```

- 환경변수를 편집할 때는 번거롭도라도 다른 변수에 복사를 해두고 편집을 하는 것이 좋습니다.

- **LANG**:

- 로케일 정보를 저장하고 있는 환경변수

- 현재 사용 중인 로케일 확인

```bash
echo $LANG
```

- 시스템에서 지원하는 로케일 확인
locale -a

- 로케일 설정
LANG=로케일

- 한국어 사용할 수 있도록 설정
```bash
sudo apt update
sudo apt install language-pack-ko
sudo locale-gen ko_KR.UTF-8
```

- 기타 환경 변수

- HISTFILE: 실행한 명령어를 저장할 파일 경로
- HISTFILESIZE: 실행한 명령어 저장할 개수
- HISTSIZE: 메모리에 저장할 개수
- HOME: 홈 디렉토리
- SHELL: 로그인 쉘의 경로
- PWD: 현재 작업 디렉토리

### 11) 환경 설정 파일

- 시스템을 사용하는 사용자의 환경을 설정하는 파일로 로그인 할 때 마다 무조건 실행되는 파일

- 시스템 환경 설정 파일: 유저와 상관없이 수행되는 파일

- /etc/profile: 모든 쉘에 공통으로 적용되는 환경 설정 파일이며 이 파일 수행 후 에 /etc/profile.d/*.sh
- /etc/bash.bashrc: 시스템에 공통으로 적용되는 bashrc로 기본 프롬프트를 설정하고 sudo 명령과 관련된 힌트를 제공
- /etc/profile.d/*.sh: 언어나 명령 별로 각각 필요한 환경을 제공

- 사용자 환경 설정 파일: 각 사용자의 홈 디렉토리에 숨김 파일로 존재하고 사용자가 내용을 수정하고 관리하는데 로그인을 하면 시스템 환경 설정 파일이 실행되서 시스템 공통 환경을 만들고 이후에 사용자 환경 설정 파일이 실행되어 사용자 별 환경을 설정합니다.

- ~/.profile: 경로 추가 등 사용자가 정의하는 환경 설정 파일로 수행한 후 .bashrc를 실행

- ~/.bachrc: 히스토리의 크기나 기본 별명이나 함수 등을 설정

- ~/.bash_logout: 로그아웃 할 때 수행할 내용을 설정

- ~/.bash_aliases: 사용자가 정의한 별명을 별도 파일로 저장

- 환경 설정 파일을 수정하면 로그아웃을 하고 다시 로그인을 해야 적용되는데 수정 후 . 이나 source 파일명 을 이용하면 현재 상태에서 적용이 가능
source 명령은 로그아웃을 하고 로그인을 다시 한 효과를 만들어 냅니다.

- 별명을 만들고 다음에 로그인 할 때 도 사용할 수 있도록 하기

```bash
alias c=clear #현재 쉘에서만 적용 로그아웃 하거나 다시 접속하면 이 명령은 수행 안됨

vim .bash_aliases #별명을 저장할 수 있는 파일을 생성

alias c=clear #작성한 후 저장하고 빠져나옴
```

source .bash_aliases #수정한 환경설정 파일을 바로 적용

### 12) bash 옵션

- set 명령

- -o 나 +o를 지정해서 옵션 기능을 활성화하거나 비활성화할 수 있음
- -o를 지정하면 기능이 활성화되고 +o를 지정하면 비활성화
- ignoreeof 기능(쉘을 빠져나가는 기능 - CTRL + D 를 무시하는 기능)
- set -o ignoreeof #활성화 - CTRL + SHIFT + d를 눌러도 로그아웃이 되지 않음)

- noclobber: 덮어쓰기 방지 기능
touch sample #빈 파일 생성

```bash
echo $PWD > sample #출력 방향을 변경해서 내용을 기록

cat sample
```

set -o noclobber #덮어쓰기 방지 기능 활성화

```bash
echo $PWD > sample
```
