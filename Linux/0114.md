# Linux

## 1. 네트워크 관리

### 1) 네트워크 관리자

- ip 명령

- ip 명령으로 네트워크 설정이 가능하지만 재부팅하면 내용이 사라지기 때문에 내용을 보존하기 위해서는 설정 파일에 저장해야 합니다.

- 형식: ip [옵션] 객체 [서브 명령]

- 객체는 디바이스

- 옵션
V: 버전을 출력
s: 자세한 정보를 출력

- 서브 명령
address [add | del | show | help]: ip 주소 관리

route [add | del | help]: 라우팅 테이블 관리

link [set]: 네트워크 인터페이스 카드 활성화 비활성화

- 정보 조회
#전체 조회

```bash
ip address show
```

#특정 디바이스 확인
```bash
ip address show enp0s3
```

- ip 추가
```bash
sudo ip address add IP/서브넷마스크 dev 인터페이스

sudo ip address add 192.168.1.20/24 dev enp0s3
```

- ip 삭제
```bash
sudo ip address del 192.168.1.20/24 dev enp0s3
```

- 라우팅 테이블 과 게이트웨이 주소 관리
ip route 명령은 라우팅 테이블을 출력하거나 게이트웨이를 설정하고 삭제

- gateway
  - 네트워크를 다른 네트워크와 연결할 때 연결점이 되는 장치
  - 게이트웨이도 하나의 컴퓨터로 볼 수 있는데 라우터라고도 부름
  - 게이트웨이는 패킷을 보고 동일한 네트워크로 보내는 것이 아니면 외부로 전달
  - 게이트웨이가 없으면 동일한 네트워크가 아닌 컴퓨터와는 접속할 수 없음

- 라우팅 테이블 확인
```bash
ip route show
```

default는 기본 게이트웨이
10. 0.2.0/24 dev enp0s3 proto kernel scope link src 10.0.2.15 metric 100 는 서브넷 설정 과 커널이 자동 설정한 것

- 게이트웨이 설정
기본 게이트웨이: sudo ip route add default via 게이트웨이주소 dev 디바이스
```bash
sudo ip route add default via 10.0.2.1 dev enp0s3
```

- 라우팅 경로 삭제
```bash
sudo ip route del 네트워크주소
```

- 네트워크 인터페이스 관리 명령
네트워크 인터페이스 비활성화: sudo ip link set 디바이스 down
네트워크 인터페이스 활성화: sudo ip link set 디바이스 up

- **ifconfig**:

- net-tools 라는 패키지를 설치해야 사용 가능
- 형식

```bash
ifconfig [인터페이스][옵션][값]
```

- 옵션
a: 모든 인터페이스에 대한 정보를 확인
up/down: 인터페이스를 활성화하거나 비활성화
netmask 주소: 넷마스크 주소를 설정
broadcast 주소: 브로드캐스트 주소를 설정

- 모든 인터페이스 확인

```bash
ifconfig
```

```text
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255            :IP, netmask, broadcast
        inet6 fe80::a00:27ff:fec3:ca76  prefixlen 64  scopeid 0x20<link>            : IPv6 주소
        inet6 fd17:625c:f037:2:a00:27ff:fec3:ca76  prefixlen 64  scopeid 0x0<global>
        ether 08:00:27:c3:ca:76  txqueuelen 1000  (Ethernet)                : MAC Address
        RX packets 1752  bytes 663942 (663.9 KB)                    : 부팅 후 받은 패킷 수 와 바이트수
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 914  bytes 107116 (107.1 KB)                    : 부팅 후 보낸 패킷 수 와 바이트 수
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

- 인터페이스 설정
```bash
sudo ifconfig 디바이스 ip주소 netmask 서브넷마스크 broadcast 브로드캐스트주소
```

192. 168.0.101 /24로 설정

```bash
sudo ifconfig enp0s3 192.168.0.101 netmask 255.255.255.0 broadcast 192.168.0.255
```

- 게이트웨이 설정

- 기본 형식

```bash
route [명령]
```

- 명령
add: 라우팅 경로나 기본 게이트웨이 추가
del: 라우팅 경로나 기본 게이트웨이 제거

- 라우팅 테이블 보기: route
Kernel IP routing table
Destination     Gateway         Genmask         
목적지           게이트웨이    서브넷마스크(255.255.255.255 이면 호스트이고 0.0.0.0 이면 default 경로)            

Metric                     Ref                            
대상까지의 거리(리눅스에서는 사용하지 않음)    해당 경로에 대한 참조 수로 리눅스에서는 사용하지 않음

Use         Iface
사용 여부        인터페이스

- 기본 게이트웨이 설정
```bash
sudo route add default gw 게이트웨이주소 dev 인터페이스이름
```

- DNS 설정

- DNS는 domain name service의 약자로 호스트 이름을 IP 주소로 변경하는 역할
- DNS가 설정되어 있지 않으면 이름으로 다른 컴퓨터에 접속할 수 없습니다.
- 우분투는 /etc/resolv.conf 파일에 저장
기본적으로 설정된 127.0.0.53은 실제 DNS 주소가 아님
- DNS 정보 확인: resolvectl status로 확인
- DNS 설정

```bash
nmcli con mod 인터페이스이름 ipv4.dns DNS주소
```

- DNS 질의 명령: nslookup

### 2) netplan

- **개요**:

- 우분투에서 네트워크 구성을 관리하는 도구 중 하나
- 네트워크 구성을 설정 파일을 이용해서 작업
- /etc/netplan 디렉토리에 YAML 파일을 만들어주면 됩니다.
파일 이름은 아무거나 상관없습니다.

- **yaml**:

- 데이터 직렬화 양식(데이터를 텍스트로 표현하기 위한 방법)
- 사람이 읽기 쉽고 쓰기 매우 편하게 설계된 방식
- 설정 파일, 데이터 저장, 시스템 간 데이터 교환(쿠버네티스, 도커, 스프링 부트 등)에 널리 사용
- JSON이나 XML 보다 문장 구조가 단순
- 공백을 이용해서 계층 구조를 정의(들여쓰기를 이용)
- 주석 지원(#으로 시작 - JSON은 주석을 허용하지 않음)
- 상위 호환성(모든 JSON 파일은 유효한 yaml 파일)
- 확장자는 일반적으로 yaml 이나 yml을 사용

- **dhcp**:

- 동적 호스트 설정
- IP pool을 가지고 있다가 클라이언트가 접속할 때 IP를 할당해주는 서비스
- 직접 IP를 설정하면 관리자가 계속해서 IP가 중복되지 않도록 할당을 해야 하기 때문에 복잡함
- DHCP를 이용하면 부팅할 때 마다 IP가 변경될 수 있습니다.

- 인터페이스 설정

- sudo vim /etc/netplan/01-netcfg.yaml

- 작성

```bash
network:
```

  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      dhcp4: no
      addresses:
        - IP주소
      gateway4: 게이트웨이주소
      nameservers:
        addresses: [DNS 서버 주소 나열]

```bash
network:
```

  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      dhcp4: no
      addresses:
        - 192.168.0.101/24
      gateway4: 192.168.0.1
      nameservers:
        addresses: [8.8.8.8]

- 파일의 권한 설정을 수정: sudo chmod 600 /etc/netplan/01-netcfg.yaml

- 적용: sudo netplan apply 또는 재접속

### 3) hostname 설정

- **uname**:

- hostname을 출력
- 형식: uname [옵션]
- 옵션
m: 아키텍쳐
n: 호스트 이름
r: 운영체제 릴리즈 정보
s: 운영체제의 이름
v: 운영체제의 버전
a: 모든 정보

- **hostname**:

- 시스템의 네트워크 이름을 확인하거나 일시적으로 변경하고자 할 때 사용
- hostname [옵션] [이름]
- 옵션
I: 모든 IP 주소 출력
f: 전체 도메인(FQDN)
- 이름 변경(현재 세션에서만 유효)

```bash
sudo hostname itstudy
```

- **hostnamectl**:

- 호스트 이름을 확인하고 설정하는 명령
- 형식: hostnamectl [옵션] [명령]
- 옵션
h: 도움말
version: 버전 출력
- 명령
status: 현재 호스트 이름 과 관련 정보 출력
set-hostname 이름: 호스트 이름 설정

### 4) /etc/hosts 파일

- 도메인 이름을 IP 주소로 매핑하는 로컬 DNS 파일

- **역할**:

- 도메인을 IP로 변환해서 로컬에서 강제로 지정
- 127.0.0.1 localhost 로 설정되어 있으면 localhost를 접속하고자 하는 명령을 수행하면 127.0.0.1로 변환해서 수행합니다.
- DNS를 조회하지 않음

- 윈도우즈에서는 c:\windows\system32\drivers\etc\hosts

- 작성 시 주의사항

- 0.0.0.0 접속 대상 IP가 아니기 때문에 연결
- 특정 사이트 차단
0. 0.0.0 도메인

- hosts 파일을 수정 후 체크사항

- DNS 캐시를 삭제
Linux: sudo systemctl restart systemd-resolved

Windows: ipconfig /flushdns

Mac OS

```bash
    sudo dscacheutil -flushcache
    sudo killall -HUP mDNSResponder
```

- 실제 해석 확인

```bash
ping 도메인이름
```

getent hosts 도메인명

- hosts 와 DNS 우선 순위

## 1. hosts 파일

## 2. DNS 캐시

## 3. DNS 서버

- 운영하는 서버세엇 hosts 사용을 피해야 하는 이유

- DNS 변경이 반영되지 않을 수 있음
상황
    DNS에서 서버 IP
    일부 서버만 계속 예전 IP로 접속
원인
    /etc/hosts
    10.0.0.5 api.company.com
    DNS는 바뀌었지만 hosts가 우선
    서버마다 서로 다른 목적지로 접속
결과
    서버 간 통신 장애
    특정 서버에서만 장애 발생

- 서버마다 설정이 달라짐(일관성 붕괴)
    서버 A에는 hosts가 존재하고 서버 B에는 hosts 가 없는 경우

- 장애 발생 시 원인 추적이 극도로 어려움
    SSH/API/DB 의 간헐적 실패
    로그 상 네트워크 문제처럼 보임

- 서버 교체 또는 오토스케일링 과 충돌
클라우드 환경
    Auto Scaling
    Immutable Infrastructure
    Blue/Green 배포
문제
    새 서버에는 hosts가 없음
    기존 서버만 정상 동작
    배포 직후 일부 서버만 장애

- 보안 사고 위험
내부자 공격이나 침해시 피해 증폭

- 운영 자동화 도구와도 충돌
충돌 대상
    Ansible
    Terraform
    Kubernetes
    CI/CD 파이프라인
문제
    인프라 도구는 DNS 기준으로 설정함
    hosts는 로컬 수동 설정

- 허용하는 경우

로컬 개발 PC
개인 테스트 서버
단기 장애 우회

- IP 주소를 찾는 과정

URL을 입력 -> /etc/host.conf 조회(hosts 파일의 위치를 조회) -> /etc/hosts를 조회

/etc/hosts에 있는 경우 -> IP 주소 획득

/etc/hosts에 없는 경우 -> /etc/resolv.conf를 조회해서 DNS Server 설정을 확인

DNS Server 설정이 없는 경우 -> 호스트 이름 알 수 없음

DNS Server 설정이 있는 경우 -> DNS 서버에게 질의를 해서 응답을 받아서 IP 주소 획득

### 5) 네트워크 상태 확인

- **ping**:

- 외부와 통신되는지 확인하거나 외부 서버가 동작하는지 확인할 때 사용

- 명령어 형식

```bash
ping [옵션] [목적지 주소]
```

- 옵션
a: 통신이 되면 소리가 남
q: 테스트 결과를 지속적으로 보여주지 않고 종합 결과만 출력
c 개수: 보낼 패킷 수를 지정

- 시스템에 따라서 보안을 강화하기 위해서 ping 패킷이 왔을 때 응답하지 않도록 설정하는 경우도 있기 때문에 ping으로 연결되지 않는다고 해서 무조건 해당 시스템이 동작하지 않는다고 단정할 수 없음

- 옵션없이 사용하면 Linux에서는 계속해서 패킷을 보내고 윈도우즈에서 4개만 보냄
```bash
ping www.google.com
```

- 결과
64 bytes from nchkgb-aa-in-f4.1e100.net (142.250.71.196): icmp_seq=96 ttl=255 time=40.1 ms
#64 bytes from nchkgb-aa-in-f4.1e100.net (142.250.71.196) :패킷의 크기와 목적지 주소
#icmp_seq는 응답이 보낸 ICMP 패킷의 순서
#ttl은 Time To Live의 약자로 패킷이 목적지에 도달하기까지 거친 라우터의 수를 간접적으로 알려주는 것인데 이 값을 시작점에서 라우터를 거칠 때 마다 1씩 감소
#time 은 패킷의 왕복 시간

96 packets transmitted, 95 received, 1.04167% packet loss, time 95105ms
rtt min/avg/max/mdev = 39.034/44.390/104.528/9.667 ms

#96개의 패킷을 전송했고 95개의 응답을 받음
#time 95105ms: 전체 응답에 걸린 시간
rtt min/avg/max/mdev = 39.034/44.390/104.528/9.667 ms: 가장 빠른 것 과 느리것 그리고 평균과 표준편차

- **netstat**:

- 네트워크 연결 상태, 라우팅 테이블, 인터페이스 관련 통계 등을 출력하고 현재 시스템에 열려있는 포트가 무엇인지도 확인할 수 있는 명령

- 형식

```bash
netstat [옵션]
```

- 옵션
a: 모든 소켓 정보를 출력
r: 라우팅 정보를 출력
n: 호스트 이름 대신 IP 주소로 출력
i: 모든 네트워크 인터페이스 정보를 출력
s: 프로토콜 별로 네트워크 통계 정보를 출력
p: 해당 소켓과 관련된 프로세스 이름과 PID를 출력

- 열려있는 포트 확인
```bash
netstat -an | grep LISTEN
```

tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
#TCP를 사용하고 두번째 0은 수신 대기 큐의 크기이고 세번째 0은 아직 처리되지 않은 패킷의 수 이고 로컬 컴퓨터의 주소 와 포트이고 뒤의 것은 원격 컴퓨터의 주소 와 포트이며 마지막은 현재 상태

unix  2      [ ACC ]     SEQPACKET  LISTENING     3344     /run/udev/control
#유닉스 소켓의 상태를 해석하는 것

- 열려있는 포트를 사용 중인 프로세스 확인: netstat -p

- 프로토콜 별로 사용 중인 포트 통계 정보: netstat -s  

- MAC Address 와 IP 주소 확인

- ARP(Address Resolution Protocol)
- 동일한 네트워크에 연결되 시스템들의 MAC Address 와 IP 주소를 확인하는 명령

```bash
arp [IP주소]
```

- 패킷 캡쳐 명령

- tcpdump
- 형식: tcp [옵션]
- 옵션
c 패킷수: 개수만큼 덤프받고 종료
i 인터페이스: 인터페이스를 지정
n: IP 주소를 호스트이름으로 변경하지 않음
q: 정보를 간단하게 출력
X: 패킷의 내용을 16진수로 출력
w 파일명: 파일에 기록
r 파일명: 파일에서 읽어옴
host 호스트이름: 지정한 호스트가 보낸 패킷만 덤프
port 포트번호: 지정한 포트 번호 패킷만 덤프

```bash
ip: IP 패킷만 덤프
```

### 6) Virtual Box에서 하나의 네트워크에 묶인 컴퓨터 만들기

- NAT 네트워크 생성

- Virtual Box에서 네트워크 메뉴를 선택하고 오른쪽 탭에서 NAT 네트워크를 선택하고 만들기 클릭
- 만들어진 네트워크를 선택하고 일반 옵션을 선택
- 이름을 수정하고 네트워크의 IP 대역을 설정(10.0.2.0/24)하고 DHCP 활성화 해제(해제하지 않으면 IP 수정 못함)

- 필요한 만큼 가상머신을 생성

- 네트워크에 편입

- 가상머신을 선택하고 [설정] 메뉴를 누르고 네트워크로 이동

- Attach to를 NAT 네트워크로 변경하고 아래에서 이름 선택

- 컴퓨터 하나의 인터페이스 확인 및 IP 설정

- 부팅을 수행

- sudo nano /etc/netplan/00-installer-config.yaml

```bash
network:
```

  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      dhcp4: no
      addresses: [10.0.2.101/24]
      gateway4: 10.0.2.1
      nameservers:
        addresses: [8.8.8.8, 1.1.1.1]

- 적용: sudo netplan apply

- 확인: ip address show

- 호스트 이름 변경

- 변경

```bash
sudo hostnamectl set-hostname master
```

- 확인
```bash
cat /etc/hostname
```

- 호스트 이름을 /etc/hosts에 설정

- sudo nano /etc/hosts

10. 0.2.101 master

10. 0.2.102 worker1

### 7) 실습

- 3개의 Linux 가상 머신을 만들고 하나의 네트워크로 묶기

- ping 명령으로 컴퓨터들이 통신이 되는지 확인
- hostname으로도 ping이 가능한 지 확인
