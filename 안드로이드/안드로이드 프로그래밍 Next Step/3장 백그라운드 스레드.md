> 어렵다.. 이책은 어렵다

# 프리뷰 
> https://developer.android.com/guide/components/processes-and-threads
### 프로세스

프로세스는 프로그램의 실행. 작업의 단위이다. 안드로이드 공식 문서에 의하면 한 앱의 실행은 한 프로세스에서 처리되며, 바꾸지 말라고 말한다.
프로세스 간은 메모리 공유가 안된다

기본적으로 안드로이드 앱을 실행하면 Activity, Service, BroadcastReceiver, ContentProvider  **모두 같은 프로세스에서 실행**된다.
그러므로 프로세스 = 프로그램의 실행이 맞는 말인셈
앱 하나 실행 = 프로세스 하나

### 스레드
스레드는 프로세스 안에서의 실행 단위이다.
정확히 말하면 프로세스 안에서의 실행 흐름이라고 보는게 맞겠다
하나의 프로세스가 하나의 앱이니까 
하나의 앱에서 여러개의 일? 흐름? 이라고 생각하면 될 것 같다

같은 프로세스 안에서의 스레드들은 서로 메모리 공유가 가능하다.

안드로이드는 크게 UI 스레드(메인스레드)와 백그라운드 스레드가 존재한다.
### UI 스레드 = 메인 스레드
UI 스레드는 막으면 안됨
5초 이상 UI 스레드가 멈추면 ANR (Application Not Responding)
UI변경은 UI 스레드에서만 

### 백드라운드 스레드 = 워커스레드
네트워크 통신, DB 조회, 이미지 디코딩, IO, 복잡한 연산 등

스레드는 직접 관리하기 어려움
그래서 도구를 씀 Handler, Executor, Coroutine, WorkManager 

# 3장 시작
> 3장에서 다루는 내용은 `HandlerThread` -> `AsyncTack` 순서로 이어진다.

## `HandlerThread`

기본적으로 안드로이드 앱을 실행하면 Activity,Service, BroadcastReceiver, ContentProvider  **모두 같은 프로세스에서 실행**된다.
그러므로 프로세스 = 프로그램의 실행이 맞는 말인셈
앱 하나 실행 = 프로세스 하나

UI 스레드(메인스레드)와 백그라운드 스레드가 존재한다.

`HandlerThread`는 `Thread`를 상속 받음

백그라운드 스레드에서 핸들러 기본 생성자를 사용하려면 루퍼가 필요하다

핸들러 = 
루퍼 =

`Looper.loop()`가 있어 리턴이 없으므로
`Looper.quit()`는 다른 스레드에서 해줘야함


1. 핸들러를 스레드 안에 두고 쓰는 방식
2. 스레드에서 루퍼를 시작하고, 스레드 외부에서 핸들러를 시작하는 방식


> 즐겨찾기 (체크박스)를 마구 클릭하면 일어나는 일
> 스레드 생성 -> (해제) -> 또 생성 -> 반복...
> 스레드는 기본적으로 순서를 보장하지 않는다.
> 그래서 큐를 사용한다. 


스레드풀도 큐의 개념

## `AsyncTask`
>스레드보다 `AsyncTask`를 안드로이드 개발자가 선호
>스레드는 Java 차원
>`AsyncTask`는 안드로이드 API임. 사용하기 더 쉬움
>but, 안드로이드 api임과는 별개로 `AsyncTask`는로 인해 메모리 누수가 생길 수 있음
>왜? 액티비티 라이프사이클을 따라가지 않기 때문
액티비티는 종료되었지만 AsyncTask가 남아있을 수 있음 = 메모리 누수

메모리 누수를 막기 위해서는 isCancell을 쓸 수 있음. 
onDestory에 넣어주면 됨

> 약간 딴 소리지만
> 액티비티 생성은 객체 생성의 개념임 (인스턴스)
> 코루틴을 라이프사이클에 맞춰서 쓰는 것이 베스트지 않을까!

### AsyncTask의 단점. 예외처리가 까다롭다.

이를 위한 해결책이 RxJava.
RxJava는 onError를 오버로딩해서 쓰는 만큼 에러처리가 간단함

### AsyncTask의 문제 2 병렬실행시 순서를 보장하지 않음

한화면에서 REST API 두개이상 호출할 수 있음
but 병렬도 순서가 중요할때가 있다. (개요-상세) 순이라던가
레이스 컨디션이 발생할 수 있음
스레드 간의 순서를 함부로 가정할 수 없음. 운빨임
=> 차라리 순차써라

실행순서 조정도구 = `CountDownLatch`



